
<!DOCTYPE html>
<html><!--
	MIT License
	
	Copyright (c) 2023 xnbox team
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
	
	HOME:   https://xnbox.github.io
	E-Mail: xnbox.team@outlook.com
--><head>
<meta charset="utf-8">
<meta http-equiv="Cache-control" content="no-store">
<meta name="robots" content="none">
<meta name="robots" content="noindex">
<meta name="robots" content="nofollow">
<meta name="robots" content="noarchive">
<meta name="robots" content="unavailable_after: 1970-01-01">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="sha256" content="">
<meta name="signature" content="">
<meta name="uuid" content="00000000-0000-0000-0000-000000000000">
<meta name="size" content="0">

<link id="favicon" rel="icon" href="">
<title></title>
<style>

/* ---------------------------------------------------------------------------------------------------- */
/*! 
* @package IcoFont 
* @version 1.0.1 
* @author IcoFont https://icofont.com 
* @copyright Copyright (c) 2015 - 2022 IcoFont 
* @license - https://icofont.com/license/
*/
@font-face {
	font-family: 'IcoFont';
	font-weight: normal;
	font-style: "Regular";
	src:
		url('data:font/woff2;base64,d09GMgABAAAAAAYUAAsAAAAAC9wAAAXGAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHFQGVgCEEAqKFIhPATYCJAMoCxYABCAFhAoHgQgbPApRlFBOEdkXCTancW4tpIuVmbMpbR7e8picGHL4+9hbBPVjv733viriyaQE08R0qD8khul4YgiFRKi0RCgWGpfLFnpRPZJ6XyS1q1JdPrfJ58nt3iR7XxRG4zESzaAcGMf//551XzjNq86cpJ1MMYCKIVZGsutkQfyBLlYA0fDuyzhIJRAeyvI9Meh/7vfyfeVfoBL0g32zjN4omna+zQpsQNFFs50BzaOFbRax6yZxL3mrB3AZgZpte7p3zm7uxfhIMYo5vWh8UDfGyFklBk2rwgQpVAwlZtP8As1Ck266v4CnvCy+YENgesUMdKSLO03Fwac/RJEN/nuI174TH5sLg1EjY/1w7PHKel+QZXZdj5pXTrkidORX9vBNv3sodYyy5kPU//89YkRPaGMlGWD23zyhJJRVFSVZQYUoAWkbCn6rqV5UWcyixM9DFsFvEYsyv3VYVPkdIYbP70iwSPyOYpH5XcOiwF+UVQVoTTdAXbyDNAB+4g3pdmWyJHJXw66XKiPd9QSnj9blCaN6QZxv7aawY9I9a/YhXm+hbOqyQOHrzZOExlplHoA0H+satf7y+vNVc1tMcaBTDyNaPsRpRy7G14ajMGiVQ+2Hsa4tSAexYSVAE/XKgea1Gvhe26qBeGY+n1LrggeAIwxkB9nvV71eAG1zrumCJUg+rB4EaRE/cIHJozQ54fGEhnoAJGH+fCHrZJm3sbepv+nChSYZ+e1rfL4mp/3+de3B45G83pHKJgBpnrIAkfKWWjCBoXWbLDm1Z5XY+GiVF6tNL2esnA6NVBp5pFlqvHG1qof8chOf4m4lHThG2eG8cpN5m5QtphZLtmKsbg6a29JINS/EC1VBnU2YD2KQxM9bp5hEeIncmjsqlRm0Zow40wJEK1swgefDLNKvS2mGpsuYxMw0jldlGtE0XKo1RBhijerCd1HEul0nKb24u1xH7h43ZNa8LkJ/zi5zB14admkEFjPET0hjcPSvzY6wzRe+x3UQdGqJ/IFBtqHWR9ahtnxsyfiGBKezaB7ZulpFWxfbI+sQm2gdCn/nDKssHz68fNb1bdoqlcOcr8e/fjY0KbGmJqFF9JQTapKG1Vzr2FI36fRLoxieHigaX56G5ROLZpcnbClLXNam2tFdo0MN4gLNtGbBtUVVC+pp6hDtiKZM14AmQScu66wuaBQcnN6lWdWD+FntXc4Ogx0d2jmHdHK4yzO7O3dyQdqc6fxd/jY71bCYLRAuxl8U7Owi/SK2ULhrooW3+1e4EH9BWF/a6nnSvgnPlr3puaIksmOPwlS67c2E0/xdCCnhh3Zyd3A6O7g7v1NEmamDs9nhXWdbhItlTrA2dpRZkbXU0chqn29Is6YZQkONjKGWgTGuQTIfc6COPvAYuzcQhUeZWWGzmKPtEnRsAE76KMMl/DE7awN3ItWkY2iRSn2USok0ozOlzktL1WtlpIjC+wN6UV4gFPC/qWdG83kV+aP2tt3ZpABT1x6pvVP0tRYZvkWVfcu+xtT83nZi52sFky8AX+TN0RCvjvzFVaR3i9Z3SicWFKcdgjQ1dsCx/DtsO/Rl1KZWsYb/0N/xvWl/KC+cJimrMgMy3oICPiQX1c2QS8qWyDVrkq3r+l70iIIGQstIQMJvION3UMDfyEVjPsklLZ/kmks/u6pbjL1K0xkh34ItvAoOYOTZUo8QoiOUlaTcO8c5IATFkMpaR8amrTIbaQJlcg1HA+9J5oEaoDmpM+dbpZLhHiDRlIlLGjlDELsFrIKnBI7HTS+t7o9AEDlzZlJFojwN51pcRK1UN0jhrumk7VGTVcWe25Bxc0Ay8iDcwMsskXJ+oQagsUR9hXRuS0kZzSyqTXauzx47xbevD7qdWhCIRBSiEYNYFIA0iEMYateeImx6h9DnyWbqfq2cCp5A1fyjU/N5v+fNDLDo9aTfeosIobeuMB1pqYAO7abyPOLQ0KZ2QXsQAgA=')
		format('woff2');
}

[class^="icofont-"], [class*=" icofont-"] {
	font-family: 'IcoFont' !important;
	speak: none;
	font-style: normal;
	font-weight: normal;
	font-variant: normal;
	text-transform: none;
	white-space: nowrap;
	word-wrap: normal;
	direction: ltr;
	line-height: 1;
	-webkit-font-feature-settings: "liga";
	-webkit-font-smoothing: antialiased;
}

.icofont-close-line:before {
  content: "\eee1";
}

.icofont-login:before {
  content: "\ef7b";
}

.icofont-logout:before {
  content: "\ef7c";
}

.icofont-navigation-menu:before {
  content: "\efa2";
}

.icofont-lock:before {
  content: "\ef7a";
}

.icofont-user:before {
  content: "\ed05";
}

.icofont-hand:before {
  content: "\ef41";
}

.icofont-warning-alt:before {
  content: "\f025";
}

.icofont-info-circle:before {
  content: "\ef4e";
}

.icofont-warning-alt {
	padding-right: .5rem;
	font-size: 1.5rem;
}

.icofont-navigation-menu {
	display: flex;
	justify-content: space-around;
	align-items: center;
	height: var(--header-height);
	width: var(--header-height);
	min-height: 100%;
	background-color: #000;
	color: #aaa;
}

.icofont-navigation-menu:hover {
	cursor: pointer;
	color: #fff;
	background-color: rgba(256, 256, 256, .08);
}

/* ---------------------------------------------------------------------------------------------------- */
* {
	--header-height: 3rem;
	--status-message-height: 2rem;
	--res-margin-verical: 1rem;
	--res-margin-horizontal: 1rem;
	--dialog-margin: 1rem;
	--green-color: #188B8B;
	--red-color: #f44336;
	--orange-color: DarkOrange;
	--green-color-with-alpha: #eee;
	--background-color: #fff;
}

* {
	scroll-margin-top: calc(var(--header-height) + var(--res-margin-verical) + var(--status-message-height));
	box-sizing: border-box;
}

*:required {
    background-color: #FFF1F1;
}

.required:after {
    content:" *";
    color: red;
}

html, body {
	height: 100%;
	padding: 0;
	margin: 0;
	overflow-x: hidden;
	background-color: var(--background-color);
	font-family: Arial, Helvetica, sans-serif;
}

header {
	position: sticky;
	width: 100%;
	top: 0;
	display: flex;
	justify-content: space-between;
	align-items: center;
	flex-grow: 0;
	flex-shrink: 0;
	height: var(--header-height);
	color: #fff;
	background-color: #24292F;
	flex-grow: 0;
	user-select: none;
	user-drag: none;
}

.close-dialog-icon {
	font-size: 1.5rem;
	position: absolute;
	top: .8rem;
	right: .8rem;
}

.close-dialog-icon:hover {
	cursor: pointer;
	padding: .3rem;
	margin: -.3rem;
	border-radius: 50%;
	background-color: rgba(0, 0, 0, .08);
}

.status-message {
	display: none;
	position: fixed;
	top: var(--header-height);
	height: 2rem;
	width: 100%;
	font-size: 1rem;
	text-align: center;
	line-height: var(--status-message-height);
}

.close-message-icon {
	font-size: 1.1rem;
	font-weight: bold;
	position: absolute;
	right: 0;
	padding-left: .5rem;
	padding-right: .5rem;
	height: 100%;
	color: #eee;
	line-height: var(--status-message-height);
}

.close-message-icon:hover {
	cursor: pointer;
	color: #fff;
	background-color: rgba(0, 0, 0, .1);
}

#integrityTestOkMessage {
	background-color: var(--green-color);
	color: White;
}

#integrityTestErrorMessage {
	background-color: var(--red-color);
	color: White;
}

#inactivityMessage {
	background-color: var(--orange-color);
	color: Black;
}

.header-left {
	height: 100%;
	display: flex;
	gap: .5rem;
	align-items: center;
}

.header-right {
	display: flex;
	gap: .5rem;
	padding-right: .8rem;
}

#appName {
	text-transform: uppercase;
	letter-spacing: 2px;
	font-size: .9rem;
	font-weight: bold;
	white-space: nowrap;
	color: DeepSkyBlue;
}

.icon-and-link {
	display: flex;
	align-items: center;
	gap: .2rem;
	font-size: .9rem;
	color: #eee;
	margin-left: .5rem;
	white-space: nowrap;
}

.icon-and-link:hover {
	cursor: pointer;
	color: #fff;
}

.menu {
	position: fixed;
	top: var(--header-height);
	z-index: 100;
	flex-direction: column;
	width: max-content;
	background-color: white;
	border: 0;
	border-bottom: 1px;
	border-color: #aaa;
	border-style: solid;
}

#menuLeft {
	left: 0;
	border-right: 1px;
	box-shadow: 10px 10px 14px -3px rgba(0, 0, 0, 0.52);
}

#menuRight {
	right: 0;
	border-left: 1px;
	box-shadow: -10px 10px 14px -3px rgba(0, 0, 0, 0.52);
}

.menu-item {
	padding-top: .3rem;
	padding-bottom: .3rem;
	padding-left: 1.5rem;
	padding-right: 1.5rem;
	font-size: .9rem;
	color: #111;
	user-select: none;
	user-drag: none;
}

.menu-item:hover {
	background-color: #DEE1E6;
	cursor: pointer;
}

.menu-item-disabled {
	cursor: default !important;
	color: #999;
}

.menu-icon {
	padding-right: .5rem;
}

.menu-separator {
	border-top: 1px solid #ddd;
}

main {
	display: flex;
	flex-direction: column;
	align-items: center;
	height: calc( 100vh - var(--header-height) );
}

.res-main {
	width: 600px;
	max-width: calc(100vw - 2 * var(--res-margin-horizontal));
	display: flex;
	flex-direction: column;
	border: 4px solid var(--green-color-with-alpha);
	box-shadow: 0px 0px 0px 1px #ddd;
	border-radius: 4px;
	margin-left: var(--res-margin-horizontal);
	margin-right: var(--res-margin-horizontal);
	margin-top: var(--res-margin-verical);
}

#statusMessageMargin {
	display: none;
	height: var(--status-message-height);
}

.res-main:last-child {
	margin-bottom: var(--res-margin-verical);
}

.res-info {
	display: flex;
	flex-direction: column;
	background-color: var(--green-color-with-alpha);
	padding: .6rem;
	user-select: none;
	user-drag: none;
	cursor: pointer;
}

.res-content {
	background-color: #fff;
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: .6rem;
	display: none;
}

.res-lock {
	visibility: hidden;
	font-size: .7rem;
	color: rgba(0, 0, 0, .6);
}

.res-id-row {
	display: flex;
	justify-content: space-between;
	font-family: monospace;
	font-size: .7rem;
	color: rgba(0, 0, 0, .6);
}

a:link.res-id,
a:visited.res-id,
a:active.res-id {
	max-width: max-content;
	color: rgba(0, 0, 0, .6) !important;
	text-decoration: none;
}

a:hover.res-id {
	text-decoration: underline;
}

.res-name {
	line-height: 1.3;
	margin-bottom: 3px;
	font-size: 1rem;
	font-weight: 400;
	color: #006E89;
	max-width: max-content;
}

.res-description {
	font-size: .9rem;
	color: #4d5156;
	max-width: max-content;
}

.res-content-root {
	display: flex;
	flex-direction: column;
	gap: .7rem;
}

.totp-code {
	background-color: #222;
	color: #fff;
	outline: 1px solid DeepSkyBlue;
	border: 5px solid #fff;
	border-radius: 4px;
	user-select: all;
	width: min-content;
	padding-top: 2px;
	padding-bottom: 2px;
	padding-left: .4rem;
	padding-right: .3rem;
	font-size: 1.1rem;
	font-family: monospace;
	font-weight: bold;
	letter-spacing: .2rem;
}

.qr-code {
	display: flex;
	width: min-content;
	height: min-content;
}

.totp-link {
	user-select: contain;
	max-width: max-content;
	word-break: break-all;
	font-family: monospace;
}

.bordered-space {
	background-color: #fff;
	border: 1px solid DeepSkyBlue;
	border-radius: 4px;
	padding: .6rem;
}

.totp-checkbox-holder {
	display: flex;
	gap: .3rem;
	width: 100%;
	justify-content: flex-start;
	font-size: 1rem;
}

.dialogTitle {
	color: #008DCD;
	font-size: 1.5rem;
	font-weight: bold;
}

.dialogTitleAbout {
	text-align: center;
}

.label {
	user-select: none;
	user-drag: none;
}

.dialogLabel {
	display: block;
	margin-top: 1rem;
	margin-bottom: .2rem;
	font-weight: bold;
}

.dialogText {
	color: #777;
	font-size: .9rem;
}

.errorMsg {
	color: red;
	font-size: .9rem;
	display: flex;
	visibility: hidden;
	align-items: center;
}


#logoIcon {
	display: none;
}

#logo {
	margin: auto;
	display: block;
    opacity: 0;
    animation: fadeIn 3s;
    animation-fill-mode: forwards;
    background-color: DeepSkyBlue;
    border: 1px solid transparent;
    border-radius: 8px;
    padding: 15px;
	user-select: none;
	user-drag: none;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.about-fields {
	max-width: min-content;
	margin: auto;
}

.about-fields td {
	cursor: default;
	font-size: .8rem;
	vertical-align: top;
	white-space: nowrap;
	word-wrap: nowrap;
}

.about-fields td:nth-child(1) {
	text-align: right;
	color: #008DCD;
	font-weight: bold;
}

td:nth-child(2) {
	color: #222;
	font-family: monospace;
}

input[type="file"] {
	display: none;
}

input[type="checkbox"] {
	margin-top: .5rem;
	margin-left: 0;
}

input[type="checkbox"] + label {
	margin-top: .5rem;
}

input:not([type="file"]):not([type="checkbox"]):not([type="button"]):not([type="submit"]),
textarea {
	width: 100%;
	padding: .7rem 1rem;
	display: inline-block;
	border: 1px solid #ccc;
	font-family: monospace;
}

input:not([type="file"]):not([type="checkbox"]):not([type="button"]):not([type="submit"]):focus,
textarea:focus {
	outline: 1px solid #000;
}

#vernamKeyTextArea {
	overflow-y: scroll;
	resize: none;
	height: 7rem;
}

dialog {
	z-index: 1000;
	border: 1px solid #aaa;
	border-radius: 4px;
	box-shadow: 10px 10px 14px -3px rgba(0, 0, 0, 0.52);
	padding: 0;
	max-width: 450px;
	min-width: 450px;
}

form {
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	margin-left: var(--dialog-margin) !important;
	margin-right: var(--dialog-margin) !important;
	height: 100%;
}

@media only screen and (max-width: 600px) {
	dialog {
		border: none;
		border-radius: 0;
		height: 100vh !important;
		min-height: 100vh !important;
		min-height: -webkit-fill-available !important;
		width: 100vw !important;
		min-width: 100vw !important;
		margin: 0;
	}
}

.topGroup {
	display: flex;
	flex-direction: column;
}

.buttonGroup {
	align-content: flex-end;
	display: flex;
	flex-direction: column;
}

.gap {
	height: 1rem;
}

.dialogButton {
	width: 100%;
	color: white;
	KKKpadding: 14px 20px;
	height: 2.5rem;
	border: none;
	outline: none;
	cursor: pointer;
}

.dialogButton:hover {
	filter: brightness(85%);
}

.button-submit {
	background-color: var(--green-color);
}

.button-cancel {
	background-color: var(--red-color);
}

.button-close {
	background-color: var(--green-color);
}

pre {
	padding: 0;
	margin: 0;
}

/* --------------------------------------------------------------------------------------------------------------------------------------- */
</style>
<template id="res-template">
				<div class="res-main">
								<div class="res-info">
												<div class="res-id-row">
																<span>ID: <a title="Short permalink to this item" class="res-id"></a></span>
																<div class="res-lock icofont-lock"></div>
												</div>
												<div class="res-name"></div>
												<div class="res-description"></div>
								</div>
								<div class="res-content">
								</div>
				</div>
</template>
</head>
<body><!--
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SVG icon
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

https://freesvg.org/1548544749
https://openclipart.org/detail/314292/cyber-griffin-silhouette
Cyber Griffin Silhouette (optimized)
-->
<svg id="logoIcon" version="1.1" xmlns:serif="http://www.serif.com/" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="144px" height="144px" viewBox="-163.708 0 1650.321 1650.321" enable-background="new 0 0 1322.905 1650.321" xml:space="preserve">
<style>fill { fill: Black; }</style>
<rect x="-163.708" width="100%" height="100%" fill="DeepSkyBlue"></rect>
<g>
	<g>
		<path class="fill" d="M1133.341,463.102c-7.012,0.214-268.13,183.99-265.45,182.109c-10.876,7.629-19.609,17.925-25.36,29.901
			c-4.595,9.57-11.317,21.375-10.716,40.213c0.088,2.758,1.844,50.499,0.31,52.916c-2.81,4.418-202.644,132.169-202.644,137.404
			c0,1.594,3.503,6.988,7.783,11.988v0.002c5.646,6.596,9.027,8.852,12.321,8.224c2.495-0.477,43.813-27.108,91.818-59.179
			c82.52-55.131,88.584-59.624,111.19-82.407l17.453-17.59c4.133-4.165,9.757-6.508,15.625-6.508
			c36.634,0,30.831,1.884,68.223-23.116c58.403-39.045,125.524-85.522,138.968-96.221c28.229-22.468,51.326-51.398,60.962-76.357
			c6.666-17.268,6.703-43.234,0.085-63.16C1145.866,477.095,1138.254,462.95,1133.341,463.102z"></path>
		<path class="fill" d="M652.093,775.979c0.712,1.854,2.133,3.37,3.16,3.37c2.424,0,68.762-43.822,76.506-48.895
			c0-75.54,0.528-146.534-2.331-148.299c-1.28-0.793-10.469,4.091-20.418,10.848c-51.177,34.761-57.996,50.544-58.135,134.506
			C650.834,752.316,651.382,774.125,652.093,775.979z"></path>
		<path class="fill" d="M1235.498,221.17c-3.539,0-27.877,16.639-174.57,119.363c-293.471,205.507-274.316,193.606-287.02,207.054
			c-5.797-4.324-11.322-8.6-27.225-19.281c-7.616-5.115-14.328-9.815-14.914-10.444c-1.361-1.456,38.703,1.01,44.808,1.34
			c196.997-133.005,436.685-297.461,449.761-307.185c51.121-38.004,76.397-75.909,76.397-114.569
			c0-21.529-17.297-72.287-24.635-72.287c-4.218,0-51.447,32.3-232.096,158.762C862.993,312.041,829.005,335.276,793.373,356.624
			c-92.282,55.287-227.044,149.134-255.612,253.313c-12.959,47.262,9.924,80.529,12.318,127.87
			c0.999,19.784,0.594,22.751-5.678,41.545c-7.875,23.593-16.386,38.494-22.492,50.066c-1.998,0.277-24.744,3.666-25.6,2.795
			c-0.358-0.366-2.122-16.004-3.918-34.753c-10.618-110.798-42.459-198.611-97.51-268.932c-5.714-7.299-10.388-13.737-10.388-14.313
			c0-1.851,25.699-45.224,24.009-49.623c-1.003-2.618-4.64-2.9-21.663-1.67c-101.286,7.305-185.694,34.329-225.704,72.256
			c-17.679,16.758-26.876,45.079-17.638,54.317c8.699,8.699,35.943,4.713,70.634-10.335c10.981-4.762,20.734-8.403,21.673-8.092
			c3.309,1.104-13.132,22.517-21.045,27.407c-10.574,6.536-38.004,7.827-68.338,3.217c-11.999-1.822-23.024-2.831-24.501-2.243
			c-3.822,1.528-22.132,26.723-28.911,39.787c-8.021,15.463-9.046,38.172-2.508,55.587c4.926,13.117,24.859,44.378,29.126,45.676
			c1.387,0.422,8.234-7.68,15.218-18.005c22.146-32.739,33.031-39.921,60.022-39.604c11.912,0.138,20.794,1.845,34.893,6.698
			c10.403,3.581,19.394,6.99,19.978,7.576c2.399,2.399,4.604,20.51,4.689,38.517c0.098,20.798-4.889,45.098-17.055,83.098
			c-9.949,31.073-15.001,41.355-35.093,71.433c-33.061,49.485-40.426,71.527-38.773,116.041c0.854,23.077,2.348,32.669,8.95,57.523
			c13.207,49.717,15.804,62.771,18.158,91.264c4.443,53.795,15.377,68.937,7.265,109.002c-4.405,21.748-3.909,39.298-4.078,166.178
			c-21.78,72.32-24.526,84.426-41.853,100.007c-13.789,12.395-30.82,22.447-38.08,22.475c-7.782,0.028-34.095-8.503-40.309-8.503
			c-4.796,0-22.515,16.969-31.702,30.357c-8.692,12.666-21.691,39.024-21.691,43.98c0,2.275,1.199,4.621,2.682,5.213
			c3.456,1.393,161.002,1.375,179.694,1.41c18.573-19.731,31.696-33.069,42.561-67.11c5.222-16.36,6.607-17.317,25.871-17.856
			c10.616-0.298,13.386-3.956,13.399-17.69c0.015-14.402,5.729-46.061,11.515-63.783c7.459-22.855,27.146-62.243,36.448-86.025
			c14.822-37.897,38.411-73.502,48.695-73.502c2.075,0,7.778,2.322,12.674,5.158c21.454,12.434,133.545,55.766,138.919,53.703
			c1.466-0.562,7.996-9.199,14.511-19.196c28.363-43.516,63.262-59.482,64.262-58.482c0.45,0.45-4.766,7.408-11.588,15.463
			c-24.516,28.947-32.092,47.616-32.092,79.092c0,47.959,24.015,93.132,73.065,137.436c26.85,24.251,46.232,44.444,46.238,48.172
			c0.007,4.619-46.37,9.768-94.802-7.077c-32.748-11.392-32.897-11.392-42.393,0.196c-18.906,23.073-36.495,61.81-31.048,68.376
			c3.138,3.784,28.598,3.192,295.009,1.973c38.548-12.131,39.686-12.824,61.55-21.801c49.89,18.191,55.157,20.498,75.952,22.198
			c52.314,4.278,87.216-34.648,87.197-97.25c-0.035-125.499-146.655-177.813-124.99-278.4c6.847-31.788,24.445-55.303,53.263-70.546
			c5.675-3.002,9.175-2.384,11.772,4.852c7.524,20.968,11.785,62.934,25.014,107.905c1.072,3.644,3.243,15.388,8.407,16.045
			c4.451,0.567,8.517-7.511,10.447-10.389c27.103-40.415,32.002-59.856,34.267-80.411c2.305-20.924-5.979-41.633-21.883-55.424
			c-18.154-15.743-37.663-30.139-62.55-31.392c-68.729-3.46-114.256,83.495-109.574,144.453
			c1.093,14.225,6.656,40.307,11.136,52.199c4.288,11.371-188.9-195.882-188.9-204.369c0-5.316,21.192-36.8,31.263-46.449
			c14.778-14.16,237.596-163.782,263.81-184.128c57.285-44.459,79.823-91.6,66.164-138.377
			c-6.317-21.633-16.394-43.675-19.965-43.675c-3.888,0-48.462,29.409-78.837,52.014c-29.453,21.916-22.25,21.747-36.216,40.91
			c-6.004,8.236-7.599,9.061-26.292,13.582c-24.848,6.01-13.979,0.159-217.385,134.617c0.844,6.518,1.31,12.146,6.543,37.514
			c5.625,27.258,5.68,39.919,0.273,61.369c-6.741,26.74-18.929,49.114-37.52,68.875c-34.382,36.548-77.531,52.798-124.542,46.903
			c-23.874-2.993-57.023-16.886-67.89-28.455c-4.186-4.457-3.673-4.38,7.911,1.18c74.478,35.745,159.891-7.591,173.959-88.26
			c11.042-63.325-26.733-120.315-91.475-138.005c-70.232-19.189-142.677,36.54-149.62,115.098
			c-0.636,6.349-0.833,14.537-0.896,23.291c-2.883-12.181-2.455-14.837-2.932-18.771c-2.876-23.702,8.66-67.165,25.659-92.832
			c20.123-30.383,44.642-47.691,90.503-63.887c28.834-10.182,50.829-21.865,91.074-48.379c23.921-15.757,32.907-22.849,33.883-26.74
			c1.697-6.765-0.848-126.562-0.83-125.552c-0.492-27.39-13.076-41.037-13.312-56.389c-0.156-10.144,11.699-18.107,19.718-19.814
			c22.84-4.859,23.624-2.199,55.224-22.402c25.395-16.234,26.248-17.027,31.491-29.313c2.963-6.945,7.018-14.954,9.006-17.796
			c3.541-5.06,3.62-4.821,3.728,11.189c0.132,19.3,3.185,24.251,13.665,22.155c7.673-1.536,22.108-3.131,29.467-3.997
			c-6.871,12.883-7.906,13.863-8.876,21.639l-0.08,0.158l0,0.511c-1.461,12.646-1.536,35.984-3.17,166.283
			c-89.601,60.162-183.222,122.134-183.222,126.779c0,4.28,19.421,15.962,24.501,14.737c4.393-1.061,198.66-130.03,202.092-134.166
			c2.105-2.537,2.412-9.274,1.3-28.476c-1.287-22.219-2.301-27.049-8.684-41.4c-9.687-21.782-9.481-27.803,1.319-38.604
			c5.263-5.263,10.949-8.401,18.837-7.933c16.637,0.987,32.958,3.83,51.52-8.937c308.075-211.899,337.262-229.073,365.583-262.254
			c10.435-12.225,22.726-34.71,26.288-48.094c3.863-14.504,2.964-40.051-1.932-54.896
			C1248.5,239.756,1239.282,221.17,1235.498,221.17z M904.899,1376.726c1.57-1.57,42.518,51.692,55.256,71.876
			c33.977,53.835,38.025,108.156,9.359,125.637c-10.386,6.334-19.108,5.262-28.86-3.547c-13.013-11.756-14.065-17.067-13.316-67.104
			c0.758-50.461-1.986-69.079-15.474-104.986C907.533,1387.07,904.399,1377.227,904.899,1376.726z"></path>
	</g>
	<circle cx="884.893" cy="790.013" r="19.026"></circle>
	<circle cx="817.631" cy="664.6" r="20.366"></circle>
	<circle cx="637.284" cy="624.404" r="21.438"></circle>
</g>
</svg><!--
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-->
				<input type="file" id="inputFileEl" accept=".xml">

				<!--
					*** Sign in Dialog ***
				-->
				<dialog id="loginDialog">
				<form id="loginForm" method="dialog">
					<div class="topGroup">
								<div class="gap"></div>
								<div class="icofont-close-line cancel-action close-dialog-icon" title="Close"></div>
							<h2 class="label dialogTitle">Sign in</h2>
							<div class="label dialogText">Enter your Griffin account details.</div>
							<br class="label">
							<div id="loginErrorMsg" class="label errorMsg" style="visibility: hidden;"><span class="icofont-warning-alt"></span>Bad credentials. Login failed!</div>
							<br class="label"> <br class="label">
							<div id="attributesDetailsHolder"></div>
							<label for="userInput" class="label dialogLabel required">User:</label>
							<input id="userInput" type="text" name="username" placeholder="Enter Username" required="" autocomplete="off" oninvalid="this.setCustomValidity('Username can not be empty!')" oninput="this.setCustomValidity('');">
							<label for="loginPasswordInput" class="label dialogLabel">Password:</label>
							<input id="loginPasswordInput" name="password" type="password" placeholder="Enter Password" autocomplete="off">
							<span>
								<input id="loginShowPassword" type="checkbox" onchange="togglePassword(this)">
								<label for="loginShowPassword" class="label">Show password</label>
							</span>
					</div>
					<div class="buttonGroup">
						<br class="label"> <br class="label"> <br class="label"> <br class="label">
						<input id="btnLoginSubmit" type="submit" class="dialogButton button-submit" value="Submit">
						<div class="gap"></div>
						<input id="btnLoginCancel" type="button" class="dialogButton button-cancel cancel-action" value="Cancel">
						<div class="gap"></div>
					</div>
				</form>
				</dialog>
				<!--
					*** Decrypt Dialog ***
				-->
				<dialog id="decryptDialog">
				<form id="decryptForm" method="dialog">
					<div class="topGroup">
								<div class="gap"></div>
								<div class="icofont-close-line cancel-action close-dialog-icon" title="Close"></div>
								<h2 class="label dialogTitle">Decrypt</h2>
								<div class="label dialogText">Enter password to decrypt resource.</div>
								<div id="decryptErrorMsg" class="label errorMsg" style="visibility: hidden;"><span class="icofont-warning-alt"></span>Bad credentials. Decrypt failed!</div>
								<label id="decryptPasswordInputLabel" for="decryptPasswordInput" class="label dialogLabel">Password:</label>
								<input id="decryptPasswordInput" name="password" type="password" placeholder="Enter Password" autocomplete="off">
								<span>
									<input id="decryptShowPassword" type="checkbox" onchange="togglePassword(this)">
									<label id="decryptShowPasswordLabel" for="decryptShowPassword" class="label">Show password</label>
								</span>
								<br class="label">
								<label id="vernamKeyTextAreaLabel" for="vernamKeyTextArea" class="label dialogLabel">Vernam key (XOR pad):</label>
								<textarea id="vernamKeyTextArea" placeholder="Enter Vernam key (XOR pad)" autocomplete="off" style="-webkit-text-security: disc;"></textarea>
								<span>
									<input id="decryptShowVernamKey" type="checkbox" onchange="togglePassword(this)">
									<label id="decryptShowVernamKeyLabel" for="decryptShowVernamKey" class="label">Show Vernam Key (XOR pad)</label>
								</span>
					</div>
					<div class="buttonGroup">
								<br class="label"> <br class="label"> <br class="label">
								<input id="btnDecryptSubmit" type="submit" class="dialogButton button-submit" value="Submit">
								<div class="gap"></div>
								<input id="btnDecryptCancel" type="button" class="dialogButton button-cancel cancel-action" value="Cancel">
								<div class="gap"></div>
					</div>
				</form>
				</dialog>
				<!--
					*** Block Dialog ***
				-->
				<dialog id="blockDialog">
				<form id="blockForm" method="dialog">
					<div class="topGroup">
								<div class="gap"></div>
								<div class="icofont-close-line cancel-action close-dialog-icon" title="Close"></div>
								<h2 class="label dialogTitle">Block user profile</h2>
								<div class="label dialogText">
												Do you really want to block user profile?<br> You can't login into your account after blocking!
								</div>
								<div id="blockErrorMsg" class="label errorMsg" style="visibility: hidden;"><span class="icofont-warning-alt"></span>Something went wrong. Please try again later.</div>
					</div>
					<div class="buttonGroup">
								<br class="label"> <br class="label"> <br class="label"> <br class="label">
								<input id="btnBlockSubmit" type="submit" class="dialogButton button-submit" value="Submit">
								<div class="gap"></div>
								<input id="btnBlockCancel" type="button" class="dialogButton button-cancel cancel-action" value="Cancel">
								<div class="gap"></div>
					</div>
				</form>
				</dialog>
				<!--
					*** Unregister Dialog ***
				-->
				<dialog id="unregisterDialog">
				<form id="unregisterForm" method="dialog">
					<div class="topGroup">
								<div class="gap"></div>
								<div class="icofont-close-line cancel-action close-dialog-icon" title="Close"></div>
								<h2 class="label dialogTitle">Unregister wallet</h2>
								<div class="label dialogText">
												Do you really want to unregister?<br> You can't login into your account after unregistering!
								</div>
					</div>
					<div class="buttonGroup">
								<br class="label"> <br class="label"> <br class="label"> <br class="label">
								<input id="btnUnregisterOk" type="submit" class="dialogButton button-submit" value="Ok">
								<div class="gap"></div>
								<input id="btnUnregisterCancel" type="button" class="dialogButton button-cancel cancel-action" value="Cancel">
								<div class="gap"></div>
					</div>
				</form>
				</dialog>
				<!--
					*** Register Dialog ***
				-->
				<dialog id="registerDialog">
				<form id="registerForm" method="dialog">
						<div class="topGroup">
								<div class="gap"></div>
								<div class="icofont-close-line cancel-action close-dialog-icon" title="Close"></div>
								<h2 class="label dialogTitle">Register wallet</h2>
								<div class="label dialogText">Register wallet open possibility to use it on this browser.</div>
								<br class="label">
								<br class="label">
								<label for="registerPasswordInput" class="label dialogLabel required">Registration Code:</label>
								<input id="registerPasswordInput" name="password" type="password" placeholder="Enter registration code" required="" autocomplete="off" oninvalid="this.setCustomValidity('Registration code can not be empty!')" oninput="this.setCustomValidity('');">
								<span>
									<input id="registerShowPassword" type="checkbox" onchange="togglePassword(this)">
									<label for="registerShowPassword" class="label">Show registration code</label>
								</span>
								</div>
								<div class="buttonGroup">
								<br class="label"> <br class="label"> <br class="label"> <br class="label">
								<input id="btnRegisterOk" type="submit" class="dialogButton button-submit" value="Ok">
								<div class="gap"></div>
								<input id="btnRegisterCancel" type="button" class="dialogButton button-cancel cancel-action" value="Cancel">
								<div class="gap"></div>
								</div>
				</form>
				</dialog>
				<!--
					*** About Dialog ***
				-->
				<dialog id="aboutDialog">
				<form id="aboutForm" method="dialog">
					<div class="topGroup">
								<div class="gap"></div>
								<div class="icofont-close-line cancel-action close-dialog-icon" title="Close"></div>
								<h2 class="label dialogTitle dialogTitleAbout">About GRIFFIN</h2>
									<img id="logo" src="">
									<br class="label">
									<br class="label">
									<hr>
									<table class="about-fields">
										<tbody>
											<tr title="Software version"><td>Ver:</td><td id="tdVersion"></td></tr>
											<tr title="Client watermark"><td>WMK:</td><td id="tdWmk"></td></tr>
											<tr title="Container identifier"><td>ID:</td><td id="tdUuid"></td></tr>
											<tr title="Encrypted data SHA-256 hash"><td>Hash:</td><td id="tdSha256"></td></tr>
											<tr title="Encrypted data size (in bytes)"><td>Size:</td><td id="tdSize"></td></tr>
											<tr title="Document subject"><td>Subject:</td><td id="tdSubject"></td></tr>
											<tr title="Document validity Not Before"><td>Validity Not Before:</td><td id="tdValidityNotBefore"></td></tr>
											<tr title="Document validity Not After"><td>Validity Not After:</td><td id="tdValidityNotAfter"></td></tr>
										</tbody>
									</table>
					</div>
					<div class="buttonGroup">
						<br class="label"> <br class="label"> <br class="label"> <br class="label">
						<input id="btnAboutClose" type="button" class="dialogButton button-close cancel-action" value="Close">
						<div class="gap"></div>
					</div>
				</form>
				</dialog>
				<header>
								<div class="header-left">
												<span id="menuIcon" class="icofont-navigation-menu"></span>
												<div id="appName"></div>
								</div>
								<div class="header-right">
												<div id="btnSignIn" class="icon-and-link" style="display: none;">
																<span class="icofont-login"></span>
																<span>Sign in</span>
												</div>
												<div id="userComponent" class="icon-and-link" style="display: none;">
														<span class="icofont-user"></span>
														<span id="userNameText"></span>
												</div>
								</div>
								<div id="integrityTestOkMessage" class="status-message" style="display: none;">Integrity test passed.<span class="icofont-close-line  close-message-icon" title="Close message"></span></div>
								<div id="integrityTestErrorMessage" class="status-message" style="display: none;">Integrity test failed!<span class="icofont-close-line close-message-icon" title="Close message"></span></div>
								<div id="inactivityMessage" class="status-message" style="display: none;"></div>
				</header>
				<div id="menuLeft" class="menu" style="display: none;">
								<a id="mnuCreateEmptyWallet" class="menu-item">Create empty wallet</a>
								<a id="mnuCreateWalletFromSource" class="menu-item">Create wallet from source…</a>
								<div class="menu-separator"></div>
								<a id="mnuInstall" class="menu-item menu-item-disabled" style="display: block;">Install…</a>
								<div class="menu-separator"></div>
								<a id="mnuRegister" class="menu-item">Register…</a>
								<a id="mnuUnregister" class="menu-item">Unregister…</a>
								<div class="menu-separator"></div>
								<a id="mnuAbout" class="menu-item">About GRIFFIN…</a>
				</div>
				<div id="menuRight" class="menu" style="display: none;">
					<a id="mnuSignOut" class="menu-item"><span class="menu-icon icofont-logout"></span>Sign Out…</a>
					<a id="mnuBlock" class="menu-item"><span class="menu-icon icofont-hand"></span>Block…</a>
				</div>
				<main>
					<div id="rootWrapper">
						<div id="statusMessageMargin" style="display: none;"></div>
						
					<div id="root"></div></div>
				</main>
				<xml id="xml" version="1.0" encoding="UTF-8"><wallet></wallet></xml>
				<div id="jsonHolder" hidden=""></div>
<script>

'use strict';

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Common utils
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// https://stackoverflow.com/a/2117523
function uuidv4() {
	return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}

//https://codegolf.stackexchange.com/questions/207178/xor-two-strings
function xorStrings(a, b) {
	let s = '';
	// use the longer of the two words to calculate the length of the result
	for (let i = 0; i < Math.max(a.length, b.length); i++) {
	  // append the result of the char from the code-point that results from
	  // XORing the char codes (or 0 if one string is too short)
	  s += String.fromCharCode(
	    (a.charCodeAt(i) || 0) ^ (b.charCodeAt(i) || 0)
	  );
	}
	return s;
}

async function digestMessage(message, alg = 'SHA-256') {
	const msgUint8 = new TextEncoder().encode(message);                           // encode as (utf-8) Uint8Array
	const hashBuffer = await crypto.subtle.digest(alg, msgUint8);           // hash the message
	const hashArray = Array.from(new Uint8Array(hashBuffer));                     // convert buffer to byte array
	return hashArray.map((b) => b.toString(16).padStart(2, '0')).join(''); // convert bytes to hex string
}

function getRandomBytes(n) {
	const bs = new Uint8Array(n);
	crypto.getRandomValues(bs);
	return bs;
}

function parsePositiveInt(s) {
	  if (s === null)
		  return 0;
	  else
	  	  s = parseInt(s);
	  if (s === NaN)
	  	  return 0;
	  if (s < 0)
	  	  return 0;
	  return s;
 }

//based on https://stackoverflow.com/a/29202760
function chunkStr(s, len) {
	const numChunks = Math.ceil(s.length / len);
	const chunks = new Array(numChunks);
	for (let i = 0, o = 0; i < numChunks; ++i, o += len)
		chunks[i] = s.substr(o, len);
	return chunks;
}

function normalize(s) {
	return s.trim().replace(/[\n\r\t\s]+/g, '');
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Common client utils
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function openXml(s) {
	const blob = new Blob([s], {
		type: 'text/xml'
	});
	const url = URL.createObjectURL(blob);
	window.open(url, '_blank');
}

//https://jsbin.com/zosayiyidu/1/edit?js,console
async function getIp(stunUrls) {
    const pc = new RTCPeerConnection({ iceServers: [ {urls: stunUrls} ] });
    pc.createDataChannel('');
	return new Promise(resolve => {
    			pc.createOffer().then(offer => pc.setLocalDescription(offer))
 			    pc.onicecandidate = async (ice) => {
 			        if (!ice || !ice.candidate || !ice.candidate.candidate) {
 			          pc.close();          
 			          return;
 			        }
 			        //console.log(ice.candidate.candidate);
 			        let split = ice.candidate.candidate.split(" ");
 			        if (split[7] === "host") {
 			          //console.log(`Local IP : ${split[4]}`);
 			        } else {
 			          //console.log(`External IP : ${split[4]}`);
 			 			resolve(split[4]);
 			        }
 			    };
 			});
}

function isAncestorOf(el, parentEl) {
	if (el == parentEl)
		return true;
	while (el.parentNode !== document.documentElement) {
		if (el.parentNode == parentEl)
			return true;
		el = el.parentNode;
	}
	return false;
}

function downloadAsHtmlFile(fileName, text) {
	const blob = new Blob([text], { type: 'text/html' });
	var url = window.URL.createObjectURL(blob);

	var link = document.createElement("a");
	link.setAttribute('download', fileName);
	link.setAttribute('href', url);
	document.body.appendChild(link);

	let clickEvent = new MouseEvent("click", {
		"view": window,
		"bubbles": true,
		"cancelable": false
	});

	link.dispatchEvent(clickEvent);
	document.body.removeChild(link);
}

function togglePassword(checkbox) {
	const el = checkbox.parentElement.previousElementSibling;
	if (el.tagName === 'TEXTAREA') {
		const key = '-webkit-text-security';
		const val = el.style.getPropertyValue(key);
		const disc = 'disc';
		if (val === disc)
			el.style.removeProperty(key);
		else
			el.style.setProperty(key, disc);
	} else
		el.type = el.type == "text" ? "password" : "text";
}
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Common MurmurHash3
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// https://github.com/perezd/node-murmurhash/blob/master/murmurhash.js
// License (MIT)
/*
 * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)
 *
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 *
 * @param {Uint8Array | string} key ASCII only
 * @param {number} seed Positive integer only
 * @return {number} 32-bit positive integer hash
 */
function MurmurHashV3(key, seed) {
	if (typeof key === 'string') key = new TextEncoder().encode(key);

	let remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;

	remainder = key.length & 3; // key.length % 4
	bytes = key.length - remainder;
	h1 = seed;
	c1 = 0xcc9e2d51;
	c2 = 0x1b873593;
	i = 0;

	while (i < bytes) {
		k1 =
			((key[i] & 0xff)) |
			((key[++i] & 0xff) << 8) |
			((key[++i] & 0xff) << 16) |
			((key[++i] & 0xff) << 24);
		++i;

		k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
		k1 = (k1 << 15) | (k1 >>> 17);
		k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

		h1 ^= k1;
		h1 = (h1 << 13) | (h1 >>> 19);
		h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
		h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
	}

	k1 = 0;

	switch (remainder) {
		case 3: k1 ^= (key[i + 2] & 0xff) << 16;
		case 2: k1 ^= (key[i + 1] & 0xff) << 8;
		case 1: k1 ^= (key[i] & 0xff);

		k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
		k1 = (k1 << 15) | (k1 >>> 17);
		k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
		h1 ^= k1;
	}

	h1 ^= key.length;

	h1 ^= h1 >>> 16;
	h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
	h1 ^= h1 >>> 13;
	h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
	h1 ^= h1 >>> 16;

	return h1 >>> 0;
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Common encrypt/decrypt
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

/*
 based on:
 https://gist.github.com/chrisveness/43bcda93af9f646d083fad678071b90a
*/
async function aesGcmEncrypt(plaintext, pwUtf8) {
	const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8);                          // hash the password

		const iv = crypto.getRandomValues(new Uint8Array(12));                             // get 96-bit random iv
		const ivStr = Array.from(iv).map(b => String.fromCharCode(b)).join('');            // iv as utf-8 string

		const alg = { name: 'AES-GCM', iv: iv };                                           // specify algorithm to use

		const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['encrypt']); // generate key from pw

		const ptUint8 = new TextEncoder().encode(plaintext);                               // encode plaintext as UTF-8
		const ctBuffer = await crypto.subtle.encrypt(alg, key, ptUint8);                   // encrypt plaintext using key

		const ctArray = Array.from(new Uint8Array(ctBuffer));                              // ciphertext as byte array
		const ctStr = ctArray.map(byte => String.fromCharCode(byte)).join('');             // ciphertext as string

		return btoa(ivStr + ctStr);                                                        // iv+ciphertext base64-encoded
	}

async function aesGcmDecrypt(ciphertext, pwUtf8) {
	try {
		const pwHash = await crypto.subtle.digest('SHA-256', pwUtf8);                      // hash the password

		const ivStr = atob(ciphertext).slice(0, 12);                                       // decode base64 iv
		const iv = new Uint8Array(Array.from(ivStr).map(ch => ch.charCodeAt(0)));          // iv as Uint8Array

		const alg = { name: 'AES-GCM', iv: iv };                                           // specify algorithm to use

		const key = await crypto.subtle.importKey('raw', pwHash, alg, false, ['decrypt']); // generate key from pw

		const ctStr = atob(ciphertext).slice(12);                                          // decode base64 ciphertext
		const ctUint8 = new Uint8Array(Array.from(ctStr).map(ch => ch.charCodeAt(0)));     // ciphertext as Uint8Array
		// note: why doesn't ctUint8 = new TextEncoder().encode(ctStr) work?

		const plainBuffer = await crypto.subtle.decrypt(alg, key, ctUint8);                // decrypt ciphertext using key
		return new TextDecoder().decode(plainBuffer);                                      // plaintext from ArrayBuffer
	} catch (e) {
	    return null;                                                                       // decrypt failed
	}
}

function s2bs(s) {
	return Uint8Array.from(atob(s, c => c.charCodeAt(0)));
}

function bs2s(bs) {
    return btoa([].slice.call(bs));
}


//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Common QR code
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//https://github.com/kazuhikoarase/qrcode-generator
//https://www.npmjs.com/package/qrcode-generator
//---------------------------------------------------------------------
//
//QR Code Generator for JavaScript
//
//Copyright (c) 2009 Kazuhiko Arase
//
//URL: http://www.d-project.com/
//
//Licensed under the MIT license:
//http://www.opensource.org/licenses/mit-license.php
//
//The word 'QR Code' is registered trademark of
//DENSO WAVE INCORPORATED
//http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

//---------------------------------------------------------------------
// qrcode
//---------------------------------------------------------------------

/**
* qrcode
* @param typeNumber 1 to 40
* @param errorCorrectionLevel 'L','M','Q','H'
*/
var qrcode = function(typeNumber, errorCorrectionLevel) {

 var PAD0 = 0xEC;
 var PAD1 = 0x11;

 var _typeNumber = typeNumber;
 var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
 var _modules = null;
 var _moduleCount = 0;
 var _dataCache = null;
 var _dataList = [];

 var _this = {};

 var makeImpl = function(test, maskPattern) {

   _moduleCount = _typeNumber * 4 + 17;
   _modules = function(moduleCount) {
     var modules = new Array(moduleCount);
     for (var row = 0; row < moduleCount; row += 1) {
       modules[row] = new Array(moduleCount);
       for (var col = 0; col < moduleCount; col += 1) {
         modules[row][col] = null;
       }
     }
     return modules;
   }(_moduleCount);

   setupPositionProbePattern(0, 0);
   setupPositionProbePattern(_moduleCount - 7, 0);
   setupPositionProbePattern(0, _moduleCount - 7);
   setupPositionAdjustPattern();
   setupTimingPattern();
   setupTypeInfo(test, maskPattern);

   if (_typeNumber >= 7) {
     setupTypeNumber(test);
   }

   if (_dataCache == null) {
     _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
   }

   mapData(_dataCache, maskPattern);
 };

 var setupPositionProbePattern = function(row, col) {

   for (var r = -1; r <= 7; r += 1) {

     if (row + r <= -1 || _moduleCount <= row + r) continue;

     for (var c = -1; c <= 7; c += 1) {

       if (col + c <= -1 || _moduleCount <= col + c) continue;

       if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
           || (0 <= c && c <= 6 && (r == 0 || r == 6) )
           || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
         _modules[row + r][col + c] = true;
       } else {
         _modules[row + r][col + c] = false;
       }
     }
   }
 };

 var getBestMaskPattern = function() {

   var minLostPoint = 0;
   var pattern = 0;

   for (var i = 0; i < 8; i += 1) {

     makeImpl(true, i);

     var lostPoint = QRUtil.getLostPoint(_this);

     if (i == 0 || minLostPoint > lostPoint) {
       minLostPoint = lostPoint;
       pattern = i;
     }
   }

   return pattern;
 };

 var setupTimingPattern = function() {

   for (var r = 8; r < _moduleCount - 8; r += 1) {
     if (_modules[r][6] != null) {
       continue;
     }
     _modules[r][6] = (r % 2 == 0);
   }

   for (var c = 8; c < _moduleCount - 8; c += 1) {
     if (_modules[6][c] != null) {
       continue;
     }
     _modules[6][c] = (c % 2 == 0);
   }
 };

 var setupPositionAdjustPattern = function() {

   var pos = QRUtil.getPatternPosition(_typeNumber);

   for (var i = 0; i < pos.length; i += 1) {

     for (var j = 0; j < pos.length; j += 1) {

       var row = pos[i];
       var col = pos[j];

       if (_modules[row][col] != null) {
         continue;
       }

       for (var r = -2; r <= 2; r += 1) {

         for (var c = -2; c <= 2; c += 1) {

           if (r == -2 || r == 2 || c == -2 || c == 2
               || (r == 0 && c == 0) ) {
             _modules[row + r][col + c] = true;
           } else {
             _modules[row + r][col + c] = false;
           }
         }
       }
     }
   }
 };

 var setupTypeNumber = function(test) {

   var bits = QRUtil.getBCHTypeNumber(_typeNumber);

   for (var i = 0; i < 18; i += 1) {
     var mod = (!test && ( (bits >> i) & 1) == 1);
     _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
   }

   for (var i = 0; i < 18; i += 1) {
     var mod = (!test && ( (bits >> i) & 1) == 1);
     _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
   }
 };

 var setupTypeInfo = function(test, maskPattern) {

   var data = (_errorCorrectionLevel << 3) | maskPattern;
   var bits = QRUtil.getBCHTypeInfo(data);

   // vertical
   for (var i = 0; i < 15; i += 1) {

     var mod = (!test && ( (bits >> i) & 1) == 1);

     if (i < 6) {
       _modules[i][8] = mod;
     } else if (i < 8) {
       _modules[i + 1][8] = mod;
     } else {
       _modules[_moduleCount - 15 + i][8] = mod;
     }
   }

   // horizontal
   for (var i = 0; i < 15; i += 1) {

     var mod = (!test && ( (bits >> i) & 1) == 1);

     if (i < 8) {
       _modules[8][_moduleCount - i - 1] = mod;
     } else if (i < 9) {
       _modules[8][15 - i - 1 + 1] = mod;
     } else {
       _modules[8][15 - i - 1] = mod;
     }
   }

   // fixed module
   _modules[_moduleCount - 8][8] = (!test);
 };

 var mapData = function(data, maskPattern) {

   var inc = -1;
   var row = _moduleCount - 1;
   var bitIndex = 7;
   var byteIndex = 0;
   var maskFunc = QRUtil.getMaskFunction(maskPattern);

   for (var col = _moduleCount - 1; col > 0; col -= 2) {

     if (col == 6) col -= 1;

     while (true) {

       for (var c = 0; c < 2; c += 1) {

         if (_modules[row][col - c] == null) {

           var dark = false;

           if (byteIndex < data.length) {
             dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
           }

           var mask = maskFunc(row, col - c);

           if (mask) {
             dark = !dark;
           }

           _modules[row][col - c] = dark;
           bitIndex -= 1;

           if (bitIndex == -1) {
             byteIndex += 1;
             bitIndex = 7;
           }
         }
       }

       row += inc;

       if (row < 0 || _moduleCount <= row) {
         row -= inc;
         inc = -inc;
         break;
       }
     }
   }
 };

 var createBytes = function(buffer, rsBlocks) {

   var offset = 0;

   var maxDcCount = 0;
   var maxEcCount = 0;

   var dcdata = new Array(rsBlocks.length);
   var ecdata = new Array(rsBlocks.length);

   for (var r = 0; r < rsBlocks.length; r += 1) {

     var dcCount = rsBlocks[r].dataCount;
     var ecCount = rsBlocks[r].totalCount - dcCount;

     maxDcCount = Math.max(maxDcCount, dcCount);
     maxEcCount = Math.max(maxEcCount, ecCount);

     dcdata[r] = new Array(dcCount);

     for (var i = 0; i < dcdata[r].length; i += 1) {
       dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
     }
     offset += dcCount;

     var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
     var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

     var modPoly = rawPoly.mod(rsPoly);
     ecdata[r] = new Array(rsPoly.getLength() - 1);
     for (var i = 0; i < ecdata[r].length; i += 1) {
       var modIndex = i + modPoly.getLength() - ecdata[r].length;
       ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
     }
   }

   var totalCodeCount = 0;
   for (var i = 0; i < rsBlocks.length; i += 1) {
     totalCodeCount += rsBlocks[i].totalCount;
   }

   var data = new Array(totalCodeCount);
   var index = 0;

   for (var i = 0; i < maxDcCount; i += 1) {
     for (var r = 0; r < rsBlocks.length; r += 1) {
       if (i < dcdata[r].length) {
         data[index] = dcdata[r][i];
         index += 1;
       }
     }
   }

   for (var i = 0; i < maxEcCount; i += 1) {
     for (var r = 0; r < rsBlocks.length; r += 1) {
       if (i < ecdata[r].length) {
         data[index] = ecdata[r][i];
         index += 1;
       }
     }
   }

   return data;
 };

 var createData = function(typeNumber, errorCorrectionLevel, dataList) {

   var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);

   var buffer = qrBitBuffer();

   for (var i = 0; i < dataList.length; i += 1) {
     var data = dataList[i];
     buffer.put(data.getMode(), 4);
     buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
     data.write(buffer);
   }

   // calc num max data.
   var totalDataCount = 0;
   for (var i = 0; i < rsBlocks.length; i += 1) {
     totalDataCount += rsBlocks[i].dataCount;
   }

   if (buffer.getLengthInBits() > totalDataCount * 8) {
     throw 'code length overflow. ('
       + buffer.getLengthInBits()
       + '>'
       + totalDataCount * 8
       + ')';
   }

   // end code
   if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
     buffer.put(0, 4);
   }

   // padding
   while (buffer.getLengthInBits() % 8 != 0) {
     buffer.putBit(false);
   }

   // padding
   while (true) {

     if (buffer.getLengthInBits() >= totalDataCount * 8) {
       break;
     }
     buffer.put(PAD0, 8);

     if (buffer.getLengthInBits() >= totalDataCount * 8) {
       break;
     }
     buffer.put(PAD1, 8);
   }

   return createBytes(buffer, rsBlocks);
 };

 _this.addData = function(data, mode) {

   mode = mode || 'Byte';

   var newData = null;

   switch(mode) {
   case 'Numeric' :
     newData = qrNumber(data);
     break;
   case 'Alphanumeric' :
     newData = qrAlphaNum(data);
     break;
   case 'Byte' :
     newData = qr8BitByte(data);
     break;
   case 'Kanji' :
     newData = qrKanji(data);
     break;
   default :
     throw 'mode:' + mode;
   }

   _dataList.push(newData);
   _dataCache = null;
 };

 _this.isDark = function(row, col) {
   if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
     throw row + ',' + col;
   }
   return _modules[row][col];
 };

 _this.getModuleCount = function() {
   return _moduleCount;
 };

 _this.make = function() {
   if (_typeNumber < 1) {
     var typeNumber = 1;

     for (; typeNumber < 40; typeNumber++) {
       var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
       var buffer = qrBitBuffer();

       for (var i = 0; i < _dataList.length; i++) {
         var data = _dataList[i];
         buffer.put(data.getMode(), 4);
         buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
         data.write(buffer);
       }

       var totalDataCount = 0;
       for (var i = 0; i < rsBlocks.length; i++) {
         totalDataCount += rsBlocks[i].dataCount;
       }

       if (buffer.getLengthInBits() <= totalDataCount * 8) {
         break;
       }
     }

     _typeNumber = typeNumber;
   }

   makeImpl(false, getBestMaskPattern() );
 };

// griffin: add color parameter
 _this.createSvgTag = function(cellSize, margin, alt, title, color) {

   var opts = {};
   if (typeof arguments[0] == 'object') {
     // Called by options.
     opts = arguments[0];
     // overwrite cellSize and margin.
     cellSize = opts.cellSize;
     margin = opts.margin;
     alt = opts.alt;
     title = opts.title;
   }

   cellSize = cellSize || 2;
   margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

   // Compose alt property surrogate
   alt = (typeof alt === 'string') ? {text: alt} : alt || {};
   alt.text = alt.text || null;
   alt.id = (alt.text) ? alt.id || 'qrcode-description' : null;

   // Compose title property surrogate
   title = (typeof title === 'string') ? {text: title} : title || {};
   title.text = title.text || null;
   title.id = (title.text) ? title.id || 'qrcode-title' : null;

   var size = _this.getModuleCount() * cellSize + margin * 2;
   var c, mc, r, mr, qrSvg='', rect;

   rect = 'l' + cellSize + ',0 0,' + cellSize +
     ' -' + cellSize + ',0 0,-' + cellSize + 'z ';

   qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
   qrSvg += !opts.scalable ? ' width="' + size + 'px" height="' + size + 'px"' : '';
   qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
   qrSvg += ' preserveAspectRatio="xMinYMin meet"';
   qrSvg += (title.text || alt.text) ? ' role="img" aria-labelledby="' +
       escapeXml([title.id, alt.id].join(' ').trim() ) + '"' : '';
   qrSvg += '>';
   qrSvg += (title.text) ? '<title id="' + escapeXml(title.id) + '">' +
       escapeXml(title.text) + '</title>' : '';
   qrSvg += (alt.text) ? '<description id="' + escapeXml(alt.id) + '">' +
       escapeXml(alt.text) + '</description>' : '';
   qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
   qrSvg += '<path d="';

   for (r = 0; r < _this.getModuleCount(); r += 1) {
     mr = r * cellSize + margin;
     for (c = 0; c < _this.getModuleCount(); c += 1) {
       if (_this.isDark(r, c) ) {
         mc = c*cellSize+margin;
         qrSvg += 'M' + mc + ',' + mr + rect;
       }
     }
   }

   qrSvg += '" stroke="transparent" fill="' + color + '"/>';
   qrSvg += '</svg>';

   return qrSvg;
 };

 _this.renderTo2dContext = function(context, cellSize) {
   cellSize = cellSize || 2;
   var length = _this.getModuleCount();
   for (var row = 0; row < length; row++) {
     for (var col = 0; col < length; col++) {
       context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
       context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
     }
   }
 }

 return _this;
};

//---------------------------------------------------------------------
// qrcode.stringToBytes
//---------------------------------------------------------------------

qrcode.stringToBytesFuncs = {
 'default' : function(s) {
   var bytes = [];
   for (var i = 0; i < s.length; i += 1) {
     var c = s.charCodeAt(i);
     bytes.push(c & 0xff);
   }
   return bytes;
 }
};

qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];

//---------------------------------------------------------------------
// qrcode.createStringToBytes
//---------------------------------------------------------------------

/**
* @param unicodeData base64 string of byte array.
* [16bit Unicode],[16bit Bytes], ...
* @param numChars
*/
qrcode.createStringToBytes = function(unicodeData, numChars) {

 // create conversion map.

 var unicodeMap = function() {

   var bin = base64DecodeInputStream(unicodeData);
   var read = function() {
     var b = bin.read();
     if (b == -1) throw 'eof';
     return b;
   };

   var count = 0;
   var unicodeMap = {};
   while (true) {
     var b0 = bin.read();
     if (b0 == -1) break;
     var b1 = read();
     var b2 = read();
     var b3 = read();
     var k = String.fromCharCode( (b0 << 8) | b1);
     var v = (b2 << 8) | b3;
     unicodeMap[k] = v;
     count += 1;
   }
   if (count != numChars) {
     throw count + ' != ' + numChars;
   }

   return unicodeMap;
 }();

 var unknownChar = '?'.charCodeAt(0);

 return function(s) {
   var bytes = [];
   for (var i = 0; i < s.length; i += 1) {
     var c = s.charCodeAt(i);
     if (c < 128) {
       bytes.push(c);
     } else {
       var b = unicodeMap[s.charAt(i)];
       if (typeof b == 'number') {
         if ( (b & 0xff) == b) {
           // 1byte
           bytes.push(b);
         } else {
           // 2bytes
           bytes.push(b >>> 8);
           bytes.push(b & 0xff);
         }
       } else {
         bytes.push(unknownChar);
       }
     }
   }
   return bytes;
 };
};

//---------------------------------------------------------------------
// QRMode
//---------------------------------------------------------------------

var QRMode = {
 MODE_NUMBER :    1 << 0,
 MODE_ALPHA_NUM : 1 << 1,
 MODE_8BIT_BYTE : 1 << 2,
 MODE_KANJI :     1 << 3
};

//---------------------------------------------------------------------
// QRErrorCorrectionLevel
//---------------------------------------------------------------------

var QRErrorCorrectionLevel = {
 L : 1,
 M : 0,
 Q : 3,
 H : 2
};

//---------------------------------------------------------------------
// QRMaskPattern
//---------------------------------------------------------------------

var QRMaskPattern = {
 PATTERN000 : 0,
 PATTERN001 : 1,
 PATTERN010 : 2,
 PATTERN011 : 3,
 PATTERN100 : 4,
 PATTERN101 : 5,
 PATTERN110 : 6,
 PATTERN111 : 7
};

//---------------------------------------------------------------------
// QRUtil
//---------------------------------------------------------------------

var QRUtil = function() {

 var PATTERN_POSITION_TABLE = [
   [],
   [6, 18],
   [6, 22],
   [6, 26],
   [6, 30],
   [6, 34],
   [6, 22, 38],
   [6, 24, 42],
   [6, 26, 46],
   [6, 28, 50],
   [6, 30, 54],
   [6, 32, 58],
   [6, 34, 62],
   [6, 26, 46, 66],
   [6, 26, 48, 70],
   [6, 26, 50, 74],
   [6, 30, 54, 78],
   [6, 30, 56, 82],
   [6, 30, 58, 86],
   [6, 34, 62, 90],
   [6, 28, 50, 72, 94],
   [6, 26, 50, 74, 98],
   [6, 30, 54, 78, 102],
   [6, 28, 54, 80, 106],
   [6, 32, 58, 84, 110],
   [6, 30, 58, 86, 114],
   [6, 34, 62, 90, 118],
   [6, 26, 50, 74, 98, 122],
   [6, 30, 54, 78, 102, 126],
   [6, 26, 52, 78, 104, 130],
   [6, 30, 56, 82, 108, 134],
   [6, 34, 60, 86, 112, 138],
   [6, 30, 58, 86, 114, 142],
   [6, 34, 62, 90, 118, 146],
   [6, 30, 54, 78, 102, 126, 150],
   [6, 24, 50, 76, 102, 128, 154],
   [6, 28, 54, 80, 106, 132, 158],
   [6, 32, 58, 84, 110, 136, 162],
   [6, 26, 54, 82, 110, 138, 166],
   [6, 30, 58, 86, 114, 142, 170]
 ];
 var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
 var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
 var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

 var _this = {};

 var getBCHDigit = function(data) {
   var digit = 0;
   while (data != 0) {
     digit += 1;
     data >>>= 1;
   }
   return digit;
 };

 _this.getBCHTypeInfo = function(data) {
   var d = data << 10;
   while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
     d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
   }
   return ( (data << 10) | d) ^ G15_MASK;
 };

 _this.getBCHTypeNumber = function(data) {
   var d = data << 12;
   while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
     d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
   }
   return (data << 12) | d;
 };

 _this.getPatternPosition = function(typeNumber) {
   return PATTERN_POSITION_TABLE[typeNumber - 1];
 };

 _this.getMaskFunction = function(maskPattern) {

   switch (maskPattern) {

   case QRMaskPattern.PATTERN000 :
     return function(i, j) { return (i + j) % 2 == 0; };
   case QRMaskPattern.PATTERN001 :
     return function(i, j) { return i % 2 == 0; };
   case QRMaskPattern.PATTERN010 :
     return function(i, j) { return j % 3 == 0; };
   case QRMaskPattern.PATTERN011 :
     return function(i, j) { return (i + j) % 3 == 0; };
   case QRMaskPattern.PATTERN100 :
     return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
   case QRMaskPattern.PATTERN101 :
     return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
   case QRMaskPattern.PATTERN110 :
     return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
   case QRMaskPattern.PATTERN111 :
     return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

   default :
     throw 'bad maskPattern:' + maskPattern;
   }
 };

 _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
   var a = qrPolynomial([1], 0);
   for (var i = 0; i < errorCorrectLength; i += 1) {
     a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
   }
   return a;
 };

 _this.getLengthInBits = function(mode, type) {

   if (1 <= type && type < 10) {

     // 1 - 9

     switch(mode) {
     case QRMode.MODE_NUMBER    : return 10;
     case QRMode.MODE_ALPHA_NUM : return 9;
     case QRMode.MODE_8BIT_BYTE : return 8;
     case QRMode.MODE_KANJI     : return 8;
     default :
       throw 'mode:' + mode;
     }

   } else if (type < 27) {

     // 10 - 26

     switch(mode) {
     case QRMode.MODE_NUMBER    : return 12;
     case QRMode.MODE_ALPHA_NUM : return 11;
     case QRMode.MODE_8BIT_BYTE : return 16;
     case QRMode.MODE_KANJI     : return 10;
     default :
       throw 'mode:' + mode;
     }

   } else if (type < 41) {

     // 27 - 40

     switch(mode) {
     case QRMode.MODE_NUMBER    : return 14;
     case QRMode.MODE_ALPHA_NUM : return 13;
     case QRMode.MODE_8BIT_BYTE : return 16;
     case QRMode.MODE_KANJI     : return 12;
     default :
       throw 'mode:' + mode;
     }

   } else {
     throw 'type:' + type;
   }
 };

 _this.getLostPoint = function(qrcode) {

   var moduleCount = qrcode.getModuleCount();

   var lostPoint = 0;

   // LEVEL1

   for (var row = 0; row < moduleCount; row += 1) {
     for (var col = 0; col < moduleCount; col += 1) {

       var sameCount = 0;
       var dark = qrcode.isDark(row, col);

       for (var r = -1; r <= 1; r += 1) {

         if (row + r < 0 || moduleCount <= row + r) {
           continue;
         }

         for (var c = -1; c <= 1; c += 1) {

           if (col + c < 0 || moduleCount <= col + c) {
             continue;
           }

           if (r == 0 && c == 0) {
             continue;
           }

           if (dark == qrcode.isDark(row + r, col + c) ) {
             sameCount += 1;
           }
         }
       }

       if (sameCount > 5) {
         lostPoint += (3 + sameCount - 5);
       }
     }
   };

   // LEVEL2

   for (var row = 0; row < moduleCount - 1; row += 1) {
     for (var col = 0; col < moduleCount - 1; col += 1) {
       var count = 0;
       if (qrcode.isDark(row, col) ) count += 1;
       if (qrcode.isDark(row + 1, col) ) count += 1;
       if (qrcode.isDark(row, col + 1) ) count += 1;
       if (qrcode.isDark(row + 1, col + 1) ) count += 1;
       if (count == 0 || count == 4) {
         lostPoint += 3;
       }
     }
   }

   // LEVEL3

   for (var row = 0; row < moduleCount; row += 1) {
     for (var col = 0; col < moduleCount - 6; col += 1) {
       if (qrcode.isDark(row, col)
           && !qrcode.isDark(row, col + 1)
           &&  qrcode.isDark(row, col + 2)
           &&  qrcode.isDark(row, col + 3)
           &&  qrcode.isDark(row, col + 4)
           && !qrcode.isDark(row, col + 5)
           &&  qrcode.isDark(row, col + 6) ) {
         lostPoint += 40;
       }
     }
   }

   for (var col = 0; col < moduleCount; col += 1) {
     for (var row = 0; row < moduleCount - 6; row += 1) {
       if (qrcode.isDark(row, col)
           && !qrcode.isDark(row + 1, col)
           &&  qrcode.isDark(row + 2, col)
           &&  qrcode.isDark(row + 3, col)
           &&  qrcode.isDark(row + 4, col)
           && !qrcode.isDark(row + 5, col)
           &&  qrcode.isDark(row + 6, col) ) {
         lostPoint += 40;
       }
     }
   }

   // LEVEL4

   var darkCount = 0;

   for (var col = 0; col < moduleCount; col += 1) {
     for (var row = 0; row < moduleCount; row += 1) {
       if (qrcode.isDark(row, col) ) {
         darkCount += 1;
       }
     }
   }

   var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
   lostPoint += ratio * 10;

   return lostPoint;
 };

 return _this;
}();

//---------------------------------------------------------------------
// QRMath
//---------------------------------------------------------------------

var QRMath = function() {

 var EXP_TABLE = new Array(256);
 var LOG_TABLE = new Array(256);

 // initialize tables
 for (var i = 0; i < 8; i += 1) {
   EXP_TABLE[i] = 1 << i;
 }
 for (var i = 8; i < 256; i += 1) {
   EXP_TABLE[i] = EXP_TABLE[i - 4]
     ^ EXP_TABLE[i - 5]
     ^ EXP_TABLE[i - 6]
     ^ EXP_TABLE[i - 8];
 }
 for (var i = 0; i < 255; i += 1) {
   LOG_TABLE[EXP_TABLE[i] ] = i;
 }

 var _this = {};

 _this.glog = function(n) {

   if (n < 1) {
     throw 'glog(' + n + ')';
   }

   return LOG_TABLE[n];
 };

 _this.gexp = function(n) {

   while (n < 0) {
     n += 255;
   }

   while (n >= 256) {
     n -= 255;
   }

   return EXP_TABLE[n];
 };

 return _this;
}();

//---------------------------------------------------------------------
// qrPolynomial
//---------------------------------------------------------------------

function qrPolynomial(num, shift) {

 if (typeof num.length == 'undefined') {
   throw num.length + '/' + shift;
 }

 var _num = function() {
   var offset = 0;
   while (offset < num.length && num[offset] == 0) {
     offset += 1;
   }
   var _num = new Array(num.length - offset + shift);
   for (var i = 0; i < num.length - offset; i += 1) {
     _num[i] = num[i + offset];
   }
   return _num;
 }();

 var _this = {};

 _this.getAt = function(index) {
   return _num[index];
 };

 _this.getLength = function() {
   return _num.length;
 };

 _this.multiply = function(e) {

   var num = new Array(_this.getLength() + e.getLength() - 1);

   for (var i = 0; i < _this.getLength(); i += 1) {
     for (var j = 0; j < e.getLength(); j += 1) {
       num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
     }
   }

   return qrPolynomial(num, 0);
 };

 _this.mod = function(e) {

   if (_this.getLength() - e.getLength() < 0) {
     return _this;
   }

   var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

   var num = new Array(_this.getLength() );
   for (var i = 0; i < _this.getLength(); i += 1) {
     num[i] = _this.getAt(i);
   }

   for (var i = 0; i < e.getLength(); i += 1) {
     num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
   }

   // recursive call
   return qrPolynomial(num, 0).mod(e);
 };

 return _this;
};

//---------------------------------------------------------------------
// QRRSBlock
//---------------------------------------------------------------------

var QRRSBlock = function() {

 var RS_BLOCK_TABLE = [

   // L
   // M
   // Q
   // H

   // 1
   [1, 26, 19],
   [1, 26, 16],
   [1, 26, 13],
   [1, 26, 9],

   // 2
   [1, 44, 34],
   [1, 44, 28],
   [1, 44, 22],
   [1, 44, 16],

   // 3
   [1, 70, 55],
   [1, 70, 44],
   [2, 35, 17],
   [2, 35, 13],

   // 4
   [1, 100, 80],
   [2, 50, 32],
   [2, 50, 24],
   [4, 25, 9],

   // 5
   [1, 134, 108],
   [2, 67, 43],
   [2, 33, 15, 2, 34, 16],
   [2, 33, 11, 2, 34, 12],

   // 6
   [2, 86, 68],
   [4, 43, 27],
   [4, 43, 19],
   [4, 43, 15],

   // 7
   [2, 98, 78],
   [4, 49, 31],
   [2, 32, 14, 4, 33, 15],
   [4, 39, 13, 1, 40, 14],

   // 8
   [2, 121, 97],
   [2, 60, 38, 2, 61, 39],
   [4, 40, 18, 2, 41, 19],
   [4, 40, 14, 2, 41, 15],

   // 9
   [2, 146, 116],
   [3, 58, 36, 2, 59, 37],
   [4, 36, 16, 4, 37, 17],
   [4, 36, 12, 4, 37, 13],

   // 10
   [2, 86, 68, 2, 87, 69],
   [4, 69, 43, 1, 70, 44],
   [6, 43, 19, 2, 44, 20],
   [6, 43, 15, 2, 44, 16],

   // 11
   [4, 101, 81],
   [1, 80, 50, 4, 81, 51],
   [4, 50, 22, 4, 51, 23],
   [3, 36, 12, 8, 37, 13],

   // 12
   [2, 116, 92, 2, 117, 93],
   [6, 58, 36, 2, 59, 37],
   [4, 46, 20, 6, 47, 21],
   [7, 42, 14, 4, 43, 15],

   // 13
   [4, 133, 107],
   [8, 59, 37, 1, 60, 38],
   [8, 44, 20, 4, 45, 21],
   [12, 33, 11, 4, 34, 12],

   // 14
   [3, 145, 115, 1, 146, 116],
   [4, 64, 40, 5, 65, 41],
   [11, 36, 16, 5, 37, 17],
   [11, 36, 12, 5, 37, 13],

   // 15
   [5, 109, 87, 1, 110, 88],
   [5, 65, 41, 5, 66, 42],
   [5, 54, 24, 7, 55, 25],
   [11, 36, 12, 7, 37, 13],

   // 16
   [5, 122, 98, 1, 123, 99],
   [7, 73, 45, 3, 74, 46],
   [15, 43, 19, 2, 44, 20],
   [3, 45, 15, 13, 46, 16],

   // 17
   [1, 135, 107, 5, 136, 108],
   [10, 74, 46, 1, 75, 47],
   [1, 50, 22, 15, 51, 23],
   [2, 42, 14, 17, 43, 15],

   // 18
   [5, 150, 120, 1, 151, 121],
   [9, 69, 43, 4, 70, 44],
   [17, 50, 22, 1, 51, 23],
   [2, 42, 14, 19, 43, 15],

   // 19
   [3, 141, 113, 4, 142, 114],
   [3, 70, 44, 11, 71, 45],
   [17, 47, 21, 4, 48, 22],
   [9, 39, 13, 16, 40, 14],

   // 20
   [3, 135, 107, 5, 136, 108],
   [3, 67, 41, 13, 68, 42],
   [15, 54, 24, 5, 55, 25],
   [15, 43, 15, 10, 44, 16],

   // 21
   [4, 144, 116, 4, 145, 117],
   [17, 68, 42],
   [17, 50, 22, 6, 51, 23],
   [19, 46, 16, 6, 47, 17],

   // 22
   [2, 139, 111, 7, 140, 112],
   [17, 74, 46],
   [7, 54, 24, 16, 55, 25],
   [34, 37, 13],

   // 23
   [4, 151, 121, 5, 152, 122],
   [4, 75, 47, 14, 76, 48],
   [11, 54, 24, 14, 55, 25],
   [16, 45, 15, 14, 46, 16],

   // 24
   [6, 147, 117, 4, 148, 118],
   [6, 73, 45, 14, 74, 46],
   [11, 54, 24, 16, 55, 25],
   [30, 46, 16, 2, 47, 17],

   // 25
   [8, 132, 106, 4, 133, 107],
   [8, 75, 47, 13, 76, 48],
   [7, 54, 24, 22, 55, 25],
   [22, 45, 15, 13, 46, 16],

   // 26
   [10, 142, 114, 2, 143, 115],
   [19, 74, 46, 4, 75, 47],
   [28, 50, 22, 6, 51, 23],
   [33, 46, 16, 4, 47, 17],

   // 27
   [8, 152, 122, 4, 153, 123],
   [22, 73, 45, 3, 74, 46],
   [8, 53, 23, 26, 54, 24],
   [12, 45, 15, 28, 46, 16],

   // 28
   [3, 147, 117, 10, 148, 118],
   [3, 73, 45, 23, 74, 46],
   [4, 54, 24, 31, 55, 25],
   [11, 45, 15, 31, 46, 16],

   // 29
   [7, 146, 116, 7, 147, 117],
   [21, 73, 45, 7, 74, 46],
   [1, 53, 23, 37, 54, 24],
   [19, 45, 15, 26, 46, 16],

   // 30
   [5, 145, 115, 10, 146, 116],
   [19, 75, 47, 10, 76, 48],
   [15, 54, 24, 25, 55, 25],
   [23, 45, 15, 25, 46, 16],

   // 31
   [13, 145, 115, 3, 146, 116],
   [2, 74, 46, 29, 75, 47],
   [42, 54, 24, 1, 55, 25],
   [23, 45, 15, 28, 46, 16],

   // 32
   [17, 145, 115],
   [10, 74, 46, 23, 75, 47],
   [10, 54, 24, 35, 55, 25],
   [19, 45, 15, 35, 46, 16],

   // 33
   [17, 145, 115, 1, 146, 116],
   [14, 74, 46, 21, 75, 47],
   [29, 54, 24, 19, 55, 25],
   [11, 45, 15, 46, 46, 16],

   // 34
   [13, 145, 115, 6, 146, 116],
   [14, 74, 46, 23, 75, 47],
   [44, 54, 24, 7, 55, 25],
   [59, 46, 16, 1, 47, 17],

   // 35
   [12, 151, 121, 7, 152, 122],
   [12, 75, 47, 26, 76, 48],
   [39, 54, 24, 14, 55, 25],
   [22, 45, 15, 41, 46, 16],

   // 36
   [6, 151, 121, 14, 152, 122],
   [6, 75, 47, 34, 76, 48],
   [46, 54, 24, 10, 55, 25],
   [2, 45, 15, 64, 46, 16],

   // 37
   [17, 152, 122, 4, 153, 123],
   [29, 74, 46, 14, 75, 47],
   [49, 54, 24, 10, 55, 25],
   [24, 45, 15, 46, 46, 16],

   // 38
   [4, 152, 122, 18, 153, 123],
   [13, 74, 46, 32, 75, 47],
   [48, 54, 24, 14, 55, 25],
   [42, 45, 15, 32, 46, 16],

   // 39
   [20, 147, 117, 4, 148, 118],
   [40, 75, 47, 7, 76, 48],
   [43, 54, 24, 22, 55, 25],
   [10, 45, 15, 67, 46, 16],

   // 40
   [19, 148, 118, 6, 149, 119],
   [18, 75, 47, 31, 76, 48],
   [34, 54, 24, 34, 55, 25],
   [20, 45, 15, 61, 46, 16]
 ];

 var qrRSBlock = function(totalCount, dataCount) {
   var _this = {};
   _this.totalCount = totalCount;
   _this.dataCount = dataCount;
   return _this;
 };

 var _this = {};

 var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {

   switch(errorCorrectionLevel) {
   case QRErrorCorrectionLevel.L :
     return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
   case QRErrorCorrectionLevel.M :
     return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
   case QRErrorCorrectionLevel.Q :
     return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
   case QRErrorCorrectionLevel.H :
     return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
   default :
     return undefined;
   }
 };

 _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {

   var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);

   if (typeof rsBlock == 'undefined') {
     throw 'bad rs block @ typeNumber:' + typeNumber +
         '/errorCorrectionLevel:' + errorCorrectionLevel;
   }

   var length = rsBlock.length / 3;

   var list = [];

   for (var i = 0; i < length; i += 1) {

     var count = rsBlock[i * 3 + 0];
     var totalCount = rsBlock[i * 3 + 1];
     var dataCount = rsBlock[i * 3 + 2];

     for (var j = 0; j < count; j += 1) {
       list.push(qrRSBlock(totalCount, dataCount) );
     }
   }

   return list;
 };

 return _this;
}();

//---------------------------------------------------------------------
// qrBitBuffer
//---------------------------------------------------------------------

var qrBitBuffer = function() {

 var _buffer = [];
 var _length = 0;

 var _this = {};

 _this.getBuffer = function() {
   return _buffer;
 };

 _this.getAt = function(index) {
   var bufIndex = Math.floor(index / 8);
   return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
 };

 _this.put = function(num, length) {
   for (var i = 0; i < length; i += 1) {
     _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
   }
 };

 _this.getLengthInBits = function() {
   return _length;
 };

 _this.putBit = function(bit) {

   var bufIndex = Math.floor(_length / 8);
   if (_buffer.length <= bufIndex) {
     _buffer.push(0);
   }

   if (bit) {
     _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
   }

   _length += 1;
 };

 return _this;
};

//---------------------------------------------------------------------
// qrNumber
//---------------------------------------------------------------------

var qrNumber = function(data) {

 var _mode = QRMode.MODE_NUMBER;
 var _data = data;

 var _this = {};

 _this.getMode = function() {
   return _mode;
 };

 _this.getLength = function(buffer) {
   return _data.length;
 };

 _this.write = function(buffer) {

   var data = _data;

   var i = 0;

   while (i + 2 < data.length) {
     buffer.put(strToNum(data.substring(i, i + 3) ), 10);
     i += 3;
   }

   if (i < data.length) {
     if (data.length - i == 1) {
       buffer.put(strToNum(data.substring(i, i + 1) ), 4);
     } else if (data.length - i == 2) {
       buffer.put(strToNum(data.substring(i, i + 2) ), 7);
     }
   }
 };

 var strToNum = function(s) {
   var num = 0;
   for (var i = 0; i < s.length; i += 1) {
     num = num * 10 + chatToNum(s.charAt(i) );
   }
   return num;
 };

 var chatToNum = function(c) {
   if ('0' <= c && c <= '9') {
     return c.charCodeAt(0) - '0'.charCodeAt(0);
   }
   throw 'illegal char :' + c;
 };

 return _this;
};

//---------------------------------------------------------------------
// qrAlphaNum
//---------------------------------------------------------------------

var qrAlphaNum = function(data) {

 var _mode = QRMode.MODE_ALPHA_NUM;
 var _data = data;

 var _this = {};

 _this.getMode = function() {
   return _mode;
 };

 _this.getLength = function(buffer) {
   return _data.length;
 };

 _this.write = function(buffer) {

   var s = _data;

   var i = 0;

   while (i + 1 < s.length) {
     buffer.put(
       getCode(s.charAt(i) ) * 45 +
       getCode(s.charAt(i + 1) ), 11);
     i += 2;
   }

   if (i < s.length) {
     buffer.put(getCode(s.charAt(i) ), 6);
   }
 };

 var getCode = function(c) {

   if ('0' <= c && c <= '9') {
     return c.charCodeAt(0) - '0'.charCodeAt(0);
   } else if ('A' <= c && c <= 'Z') {
     return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
   } else {
     switch (c) {
     case ' ' : return 36;
     case '$' : return 37;
     case '%' : return 38;
     case '*' : return 39;
     case '+' : return 40;
     case '-' : return 41;
     case '.' : return 42;
     case '/' : return 43;
     case ':' : return 44;
     default :
       throw 'illegal char :' + c;
     }
   }
 };

 return _this;
};

//---------------------------------------------------------------------
// qr8BitByte
//---------------------------------------------------------------------

var qr8BitByte = function(data) {

 var _mode = QRMode.MODE_8BIT_BYTE;
 var _data = data;
 var _bytes = qrcode.stringToBytes(data);

 var _this = {};

 _this.getMode = function() {
   return _mode;
 };

 _this.getLength = function(buffer) {
   return _bytes.length;
 };

 _this.write = function(buffer) {
   for (var i = 0; i < _bytes.length; i += 1) {
     buffer.put(_bytes[i], 8);
   }
 };

 return _this;
};

//---------------------------------------------------------------------
// qrKanji
//---------------------------------------------------------------------

var qrKanji = function(data) {

 var _mode = QRMode.MODE_KANJI;
 var _data = data;

 var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
 if (!stringToBytes) {
   throw 'sjis not supported.';
 }
 !function(c, code) {
   // self test for sjis support.
   var test = stringToBytes(c);
   if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
     throw 'sjis not supported.';
   }
 }('\u53cb', 0x9746);

 var _bytes = stringToBytes(data);

 var _this = {};

 _this.getMode = function() {
   return _mode;
 };

 _this.getLength = function(buffer) {
   return ~~(_bytes.length / 2);
 };

 _this.write = function(buffer) {

   var data = _bytes;

   var i = 0;

   while (i + 1 < data.length) {

     var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);

     if (0x8140 <= c && c <= 0x9FFC) {
       c -= 0x8140;
     } else if (0xE040 <= c && c <= 0xEBBF) {
       c -= 0xC140;
     } else {
       throw 'illegal char at ' + (i + 1) + '/' + c;
     }

     c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);

     buffer.put(c, 13);

     i += 2;
   }

   if (i < data.length) {
     throw 'illegal char at ' + (i + 1);
   }
 };

 return _this;
};

//=====================================================================
// GIF Support etc.
//

//---------------------------------------------------------------------
// byteArrayOutputStream
//---------------------------------------------------------------------

var byteArrayOutputStream = function() {

 var _bytes = [];

 var _this = {};

 _this.writeByte = function(b) {
   _bytes.push(b & 0xff);
 };

 _this.writeShort = function(i) {
   _this.writeByte(i);
   _this.writeByte(i >>> 8);
 };

 _this.writeBytes = function(b, off, len) {
   off = off || 0;
   len = len || b.length;
   for (var i = 0; i < len; i += 1) {
     _this.writeByte(b[i + off]);
   }
 };

 _this.writeString = function(s) {
   for (var i = 0; i < s.length; i += 1) {
     _this.writeByte(s.charCodeAt(i) );
   }
 };

 _this.toByteArray = function() {
   return _bytes;
 };

 _this.toString = function() {
   var s = '';
   s += '[';
   for (var i = 0; i < _bytes.length; i += 1) {
     if (i > 0) {
       s += ',';
     }
     s += _bytes[i];
   }
   s += ']';
   return s;
 };

 return _this;
};

//---------------------------------------------------------------------
// base64EncodeOutputStream
//---------------------------------------------------------------------

var base64EncodeOutputStream = function() {

 var _buffer = 0;
 var _buflen = 0;
 var _length = 0;
 var _base64 = '';

 var _this = {};

 var writeEncoded = function(b) {
   _base64 += String.fromCharCode(encode(b & 0x3f) );
 };

 var encode = function(n) {
   if (n < 0) {
     // error.
   } else if (n < 26) {
     return 0x41 + n;
   } else if (n < 52) {
     return 0x61 + (n - 26);
   } else if (n < 62) {
     return 0x30 + (n - 52);
   } else if (n == 62) {
     return 0x2b;
   } else if (n == 63) {
     return 0x2f;
   }
   throw 'n:' + n;
 };

 _this.writeByte = function(n) {

   _buffer = (_buffer << 8) | (n & 0xff);
   _buflen += 8;
   _length += 1;

   while (_buflen >= 6) {
     writeEncoded(_buffer >>> (_buflen - 6) );
     _buflen -= 6;
   }
 };

 _this.flush = function() {

   if (_buflen > 0) {
     writeEncoded(_buffer << (6 - _buflen) );
     _buffer = 0;
     _buflen = 0;
   }

   if (_length % 3 != 0) {
     // padding
     var padlen = 3 - _length % 3;
     for (var i = 0; i < padlen; i += 1) {
       _base64 += '=';
     }
   }
 };

 _this.toString = function() {
   return _base64;
 };

 return _this;
};

//---------------------------------------------------------------------
// base64DecodeInputStream
//---------------------------------------------------------------------

var base64DecodeInputStream = function(str) {

 var _str = str;
 var _pos = 0;
 var _buffer = 0;
 var _buflen = 0;

 var _this = {};

 _this.read = function() {

   while (_buflen < 8) {

     if (_pos >= _str.length) {
       if (_buflen == 0) {
         return -1;
       }
       throw 'unexpected end of file./' + _buflen;
     }

     var c = _str.charAt(_pos);
     _pos += 1;

     if (c == '=') {
       _buflen = 0;
       return -1;
     } else if (c.match(/^\s$/) ) {
       // ignore if whitespace.
       continue;
     }

     _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
     _buflen += 6;
   }

   var n = (_buffer >>> (_buflen - 8) ) & 0xff;
   _buflen -= 8;
   return n;
 };

 var decode = function(c) {
   if (0x41 <= c && c <= 0x5a) {
     return c - 0x41;
   } else if (0x61 <= c && c <= 0x7a) {
     return c - 0x61 + 26;
   } else if (0x30 <= c && c <= 0x39) {
     return c - 0x30 + 52;
   } else if (c == 0x2b) {
     return 62;
   } else if (c == 0x2f) {
     return 63;
   } else {
     throw 'c:' + c;
   }
 };

 return _this;
};

//---------------------------------------------------------------------
// gifImage (B/W)
//---------------------------------------------------------------------

var gifImage = function(width, height) {

 var _width = width;
 var _height = height;
 var _data = new Array(width * height);

 var _this = {};

 _this.setPixel = function(x, y, pixel) {
   _data[y * _width + x] = pixel;
 };

 _this.write = function(out) {

   //---------------------------------
   // GIF Signature

   out.writeString('GIF87a');

   //---------------------------------
   // Screen Descriptor

   out.writeShort(_width);
   out.writeShort(_height);

   out.writeByte(0x80); // 2bit
   out.writeByte(0);
   out.writeByte(0);

   //---------------------------------
   // Global Color Map

   // black
   out.writeByte(0x00);
   out.writeByte(0x00);
   out.writeByte(0x00);

   // white
   out.writeByte(0xff);
   out.writeByte(0xff);
   out.writeByte(0xff);

   //---------------------------------
   // Image Descriptor

   out.writeString(',');
   out.writeShort(0);
   out.writeShort(0);
   out.writeShort(_width);
   out.writeShort(_height);
   out.writeByte(0);

   //---------------------------------
   // Local Color Map

   //---------------------------------
   // Raster Data

   var lzwMinCodeSize = 2;
   var raster = getLZWRaster(lzwMinCodeSize);

   out.writeByte(lzwMinCodeSize);

   var offset = 0;

   while (raster.length - offset > 255) {
     out.writeByte(255);
     out.writeBytes(raster, offset, 255);
     offset += 255;
   }

   out.writeByte(raster.length - offset);
   out.writeBytes(raster, offset, raster.length - offset);
   out.writeByte(0x00);

   //---------------------------------
   // GIF Terminator
   out.writeString(';');
 };

 var bitOutputStream = function(out) {

   var _out = out;
   var _bitLength = 0;
   var _bitBuffer = 0;

   var _this = {};

   _this.write = function(data, length) {

     if ( (data >>> length) != 0) {
       throw 'length over';
     }

     while (_bitLength + length >= 8) {
       _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
       length -= (8 - _bitLength);
       data >>>= (8 - _bitLength);
       _bitBuffer = 0;
       _bitLength = 0;
     }

     _bitBuffer = (data << _bitLength) | _bitBuffer;
     _bitLength = _bitLength + length;
   };

   _this.flush = function() {
     if (_bitLength > 0) {
       _out.writeByte(_bitBuffer);
     }
   };

   return _this;
 };

 var getLZWRaster = function(lzwMinCodeSize) {

   var clearCode = 1 << lzwMinCodeSize;
   var endCode = (1 << lzwMinCodeSize) + 1;
   var bitLength = lzwMinCodeSize + 1;

   // Setup LZWTable
   var table = lzwTable();

   for (var i = 0; i < clearCode; i += 1) {
     table.add(String.fromCharCode(i) );
   }
   table.add(String.fromCharCode(clearCode) );
   table.add(String.fromCharCode(endCode) );

   var byteOut = byteArrayOutputStream();
   var bitOut = bitOutputStream(byteOut);

   // clear code
   bitOut.write(clearCode, bitLength);

   var dataIndex = 0;

   var s = String.fromCharCode(_data[dataIndex]);
   dataIndex += 1;

   while (dataIndex < _data.length) {

     var c = String.fromCharCode(_data[dataIndex]);
     dataIndex += 1;

     if (table.contains(s + c) ) {

       s = s + c;

     } else {

       bitOut.write(table.indexOf(s), bitLength);

       if (table.size() < 0xfff) {

         if (table.size() == (1 << bitLength) ) {
           bitLength += 1;
         }

         table.add(s + c);
       }

       s = c;
     }
   }

   bitOut.write(table.indexOf(s), bitLength);

   // end code
   bitOut.write(endCode, bitLength);

   bitOut.flush();

   return byteOut.toByteArray();
 };

 var lzwTable = function() {

   var _map = {};
   var _size = 0;

   var _this = {};

   _this.add = function(key) {
     if (_this.contains(key) ) {
       throw 'dup key:' + key;
     }
     _map[key] = _size;
     _size += 1;
   };

   _this.size = function() {
     return _size;
   };

   _this.indexOf = function(key) {
     return _map[key];
   };

   _this.contains = function(key) {
     return typeof _map[key] != 'undefined';
   };

   return _this;
 };

 return _this;
};

var createDataURL = function(width, height, getPixel) {
 var gif = gifImage(width, height);
 for (var y = 0; y < height; y += 1) {
   for (var x = 0; x < width; x += 1) {
     gif.setPixel(x, y, getPixel(x, y) );
   }
 }

 var b = byteArrayOutputStream();
 gif.write(b);

 var base64 = base64EncodeOutputStream();
 var bytes = b.toByteArray();
 for (var i = 0; i < bytes.length; i += 1) {
   base64.writeByte(bytes[i]);
 }
 base64.flush();

 return 'data:image/gif;base64,' + base64;
};

//---------------------------------------------------------------------
// returns qrcode function.

return qrcode;
}();

//multibyte support
!function() {

qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
 // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
 function toUTF8Array(str) {
   var utf8 = [];
   for (var i=0; i < str.length; i++) {
     var charcode = str.charCodeAt(i);
     if (charcode < 0x80) utf8.push(charcode);
     else if (charcode < 0x800) {
       utf8.push(0xc0 | (charcode >> 6),
           0x80 | (charcode & 0x3f));
     }
     else if (charcode < 0xd800 || charcode >= 0xe000) {
       utf8.push(0xe0 | (charcode >> 12),
           0x80 | ((charcode>>6) & 0x3f),
           0x80 | (charcode & 0x3f));
     }
     // surrogate pair
     else {
       i++;
       // UTF-16 encodes 0x10000-0x10FFFF by
       // subtracting 0x10000 and splitting the
       // 20 bits of 0x0-0xFFFFF into two halves
       charcode = 0x10000 + (((charcode & 0x3ff)<<10)
         | (str.charCodeAt(i) & 0x3ff));
       utf8.push(0xf0 | (charcode >>18),
           0x80 | ((charcode>>12) & 0x3f),
           0x80 | ((charcode>>6) & 0x3f),
           0x80 | (charcode & 0x3f));
     }
   }
   return utf8;
 }
 return toUTF8Array(s);
};

}();

(function (factory) {
if (typeof define === 'function' && define.amd) {
   define([], factory);
} else if (typeof exports === 'object') {
   module.exports = factory();
}
}(function () {
 return qrcode;
}));

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Common TOTP
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//https://github.com/wzychla/tiny-totp.js
/**
* Timed One-Time Passwords, RFC6328
* This Javascript class can generate and validate codes
* No additional external dependencies
* 
* Works in node.js and in a modern browser
* No QR code generation
* 
* Inspired by https://github.com/wuyanxin/totp.js
*/

/**
* Constructor
* 
* key is a base32 encoded string
* digits is the number of output digits
*/

'use strict';

function TOTP(key, digits = 6) {
 this.key = key;
 this.digits = digits;
}

TOTP.prototype = {

 /**
  * TOTP code generation
  */
 gen: async function(timeStep = 30, bias = 0) {

     // decode base32 encoded master key to byte array
     const _hex        = this._base32tohex(this.key);
     const _hexi       = BigInt( '0x'+_hex);        
     const _keybytes   = this._bigIntToByteArray(_hexi);

     // compute time shift to byte array
     const _time       = Math.floor((Date.now() / 1000 - bias) / timeStep);
     const _timeFactor = this._int32ToByteArray(_time);

     // compute HMACSHA1(key, shift)
         // browser. use crypto.subtle
         const key = await window.crypto.subtle.importKey(
             "raw",       // key format 
             _keybytes, { // algorithm details
                 name: "HMAC",
                 hash: {
                     name: "SHA-1"
                 }
             },
             false,   // no export 
             ["sign"] // what this key can do
         );
         
         const signature = await window.crypto.subtle.sign(
             "HMAC",
             key,
             _timeFactor
         );
         
         return this._truncate( new Uint8Array( signature ) );
 },

 /** This is supposed to convert 32-bit value to 8 byte array, padded left */
 _int32ToByteArray: function (time) {
     const _buf  = new ArrayBuffer(8);
     const _view = new DataView(_buf);
     _view.setUint32(4, time, false); 
     return _buf;
 },

 /** This is supposed to convert bitint to 16 byte array in correct endianness */
 _bigIntToByteArray: function(bigNumber) {
     let result = new Uint8Array(16);
     let i = 0;
     while (bigNumber > 0) {
         result[i++] = Number(bigNumber % BigInt(256));
         bigNumber   = bigNumber / BigInt(256);
     }
     return result.reverse();
 },

 /** This is supposed to shorten the hash to k (6) digits */
 _truncate: function (hmac) {
     const offset = hmac[hmac.length - 1] & 0xf;
     const bin_code = 
         (hmac[offset + 0] & 0x7f) << 24 |
         (hmac[offset + 1] & 0xff) << 16 |
         (hmac[offset + 2] & 0xff) << 8 |
         (hmac[offset + 3] & 0xff);
     let code = (bin_code % Math.pow(10, this.digits)).toString().padStart(6, '0');
     return code;
 },

 /**
  * https://stackoverflow.com/questions/6154361/how-to-write-a-base32-decode-in-javascript
  */
 _base32tohex: function(base32) {
     for (var base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bits = "", hex = "", i = 0; i < base32.length; i++) {
         var val = base32chars.indexOf(base32.charAt(i).toUpperCase());
         bits += val.toString(2).padStart(5, '0');
     }
     for (i = 0; i + 4 <= bits.length; i += 4) {
         var chunk = bits.substr(i, 4);
         hex += parseInt(chunk, 2).toString(16)
     }
     return hex;
 }
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Common sign and verify
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// function generateKeys() {
// 	crypto.subtle.generateKey(
// 		{
// 			name: "ECDSA",
// 			namedCurve: "P-384"
// 		},
// 		true,
// 		["sign", "verify"]
// 	).then(keys => {
// 		crypto.subtle.exportKey("pkcs8", keys.privateKey)
// 		.then(exported => {
// 			const pemExported = ab2Pem(exported, 'PRIVATE KEY');
// 			console.log(pemExported);
// 		});
// 		crypto.subtle.exportKey("spki", keys.publicKey)
// 		.then(exported => {
// 			const pemExported = ab2Pem(exported, 'PUBLIC KEY');
// 			console.log(pemExported);
// 		})
// 	});
// }

async function verifyMsg(keyFormat, algName, algEcNamedCurve, algRsaModulusLength, algRsaHash, hashAlg, pemPublicKey, pemSignature, message, callback) {
	importPublicKey(keyFormat, algName, algEcNamedCurve, algRsaModulusLength, algRsaHash, pemPublicKey).then(async publicKey => {
		const signature = pem2Ab(pemSignature, `${algName} ${hashAlg} SIGNATURE`);
		const valid = await verifyMessage(message, publicKey, signature);
		callback(valid);
	});
}

async function verifyMessage(algName, hashAlg, publicKey, signature, message) {
	return await window.crypto.subtle.verify(
		{
		  name: algName,
		  hash: hashAlg
		},
		publicKey,
		signature,
		new TextEncoder().encode(message)
  );
}


function importPublicKey(keyFormat = 'spki', algName, algEcNamedCurve, algRsaModulusLength, algRsaHash, pem) {
	const alg = createKeyAlg(algName, algEcNamedCurve, algRsaModulusLength, algRsaHash);
	return window.crypto.subtle.importKey(
		keyFormat, // E.g.: "spki",
		pem2Ab(pem, `${algName} PUBLIC KEY`),
		alg,
		true,
		["verify"]
	);
}

async function signMsg(keyFormat, algName, algEcNamedCurve, algRsaModulusLength, algRsaHash, hashAlg, pemPrivateKey, message, callback) {
	importPrivateKey(keyFormat, algName, algEcNamedCurve, algRsaModulusLength, algRsaHash, pemPrivateKey).then(async privateKey => {
		const signature = await signMessage(algName, hashAlg, privateKey, message);
		const pemSignature =  binToBase64(signature);
		callback(pemSignature);
	});
}

async function signMessage(algName, hashAlg, privateKey, message) {
	return await window.crypto.subtle.sign(
		{
			name: algName, // E.g.: "ECDSA"
			hash: hashAlg, // E.g.: "SHA-384"
		},
		privateKey,
		new TextEncoder().encode(message)
	);
}

function binToBase64(ab) {
	const str = ab2str(ab);
	return window.btoa(str); // Base64
}

function base64ToBin(base64str) {
	const str = window.atob(base64str);
	return  str2ab(str); // ArrayBuffer
}

/*
	Convert string to ArrayBuffer
	https://developer.chrome.com/blog/how-to-convert-arraybuffer-to-and-from-string/
	https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
*/
function str2ab(str) {
	const buf = new ArrayBuffer(str.length);
	const bufView = new Uint8Array(buf);
	for (let i = 0, strLen = str.length; i < strLen; i++)
		bufView[i] = str.charCodeAt(i);
	return buf;
}

/*
	Convert ArrayBuffer to string
	https://developer.chrome.com/blog/how-to-convert-arraybuffer-to-and-from-string/
	https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String
*/
function ab2str(buf) {
	return String.fromCharCode.apply(null, new Uint8Array(buf));
}

// function ab2Pem(ab, type) {
// 	const base64str = binToBase64(ab);
// 	const lines = chunkStr(base64str, 64); // https://www.rfc-editor.org/rfc/rfc1421.html
// 	let s = `-----BEGIN ${type}-----`;
// 	for (const line of lines)
// 		s += '\n' + line;
// 	return s + `\n-----END ${type}-----`;
// }

function pem2Ab(pem, type) {
	const pemHeader = `-----BEGIN ${type}-----`;
	const pemFooter = `-----END ${type}-----`;
	const startIndex = pem.indexOf(pemHeader);
	const endIndex = pem.indexOf(pemFooter);
	const base64str = normalize(pem.substring(startIndex + pemHeader.length, endIndex));
	return base64ToBin(base64str);
}

function createKeyAlg(algName, algEcNamedCurve, algRsaModulusLength, algRsaHash) {
	const alg = {
		name: algName // ECDSA, ECDH, RSASSA-PKCS1-v1_5, RSA-PSS, RSA-OAEP
	};
	if (algName.startsWith('EC')) // ECDSA, ECDH
		alg.namedCurve = algEcNamedCurve; // P-256, P-384,	P-521
	else if (algName.startsWith('RSA')) { // RSASSA-PKCS1-v1_5, RSA-PSS, RSA-OAEP
		alg.publicExponent = new Uint8Array([1, 0, 1]); // A Uint8Array. The public exponent. Unless you have a good reason to use something else, specify 65537 here ([0x01, 0x00, 0x01]).
		alg.modulusLength = modulusLength; // A Number. The length in bits of the RSA modulus. This should be at least 2048: see for example see SP 800-131A Rev. 2. Some organizations are now recommending that it should be 4096. 
		alg.hash = algRsaHash; //	A string representing the name of the digest function to use. You can pass any of SHA-256, SHA-384, or SHA-512 here.
	}
	return alg;
}

function importPrivateKey(keyFormat = 'pkcs8', algName, algEcNamedCurve, algRsaModulusLength, algRsaHash, pem) {
	const alg = createKeyAlg(algName, algEcNamedCurve, algRsaModulusLength, algRsaHash);
	return window.crypto.subtle.importKey(
		keyFormat, // E.g.: "pkcs8"
		pem2Ab(pem, `${algName} PRIVATE KEY`),
		alg,
		true,
		["sign"]
	);
}
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// *** End of common utils ***
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------








//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Section: Fetch remote server
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// async function deleteRemoteSecret(url, authorization) {
// 	return fetch(url, {
// 		method: 'DELETE',
// 		headers: {
// 			'Authorization': authorization
// 		}
// 	}).then((response) => {
// 		if (response.status >= 400) {
// 			console.log(`WARNING! Profile is not blocked. Bad HTTP status`);
// 			return false;
// 		} else {
// 			console.log(`Access is blocked successfully`);
// 			return true;
// 		}
// 	})
// 	.catch(error => {
// 		console.log(`WARNING! Error while blocking. ${error.message}`);
// 		return false;
// 	});
// }

// async function fetchAsUint8Array(url, authorization) {
// 	return fetch(url, {
// 		method: 'GET',
// 		headers: {
// 			'Authorization': authorization
// 		},
// 		cache: 'no-store'
// 	})
// 	.then((response) => {
// 		if (response.status >= 400) {
// 			console.log(`WARNING! Remote key ignored. Bad HTTP status`);
// 			return '';
// 		}
// 		return response.text();
// 	})
// 	.catch(error => {
// 		console.log(`WARNING! Remote key ignored. ${error.message}`);
// 		return '';
// 	});
// }

// async function fetchAsUint8Array(url, authorization) {
// 	return fetch(url, {
// 		method: 'GET',
// 		headers: {
// 			'Authorization': authorization
// 		},
// 		cache: 'no-store'
// 	})
// 	.then((response) => {
// 		if (response.status >= 400) {
// 			console.log(`WARNING! Remote key ignored. Bad HTTP status`);
// 			return new ArrayBuffer(0);
// 		}
// 		return response.arrayBuffer();
// 	})
// 	.then((arrayBuffer) => {
// 		return new Uint8Array(arrayBuffer);
// 	})
// 	.then((uint8Array) => {
// 		return new TextDecoder().decode(uint8Array);
// 	})
// 	.catch(error => {
// 		console.log(`WARNING! Remote key ignored. ${error.message}`);
// 		return '';
// 	});
// }

// async function fetchLog(url, eventName) {
// 	return fetch(url, {
// 		method: 'POST',
// 		cache: 'no-store',
// 		headers: {
// 			'Content-Type': 'application/json'
// 		},
// 		body: JSON.stringify({event: eventName})
// 	})
// 	.then((response) => {
// 		if (response.status >= 400)
// 			console.log(`WARNING! Logging problem. Bad HTTP status`);
// 	})
// 	.catch(error => {
// 		console.log(`WARNING! Logging problem. ${error.message}`);
// 	});
// }

/*
 * Events:
 *
 * event-open
 * event-sign-in-succes
 * event-sign-in-failed
 */
async function fetchLog(url, options) {
	options['cache'] = 'no-store';
	return fetch(url, options)
	.then((response) => {
		if (response.status >= 400)
			console.log(`WARNING! Logging problem. Bad HTTP status`);
	})
	.catch(error => {
		console.log(`WARNING! Logging problem. ${error.message}`);
	});
}

async function fetchRemoteSecret(url, options) {
	options['cache'] = 'no-store';
	return fetch(url, options)
	.then((response) => {
		if (response.status >= 400) {
			console.log(`WARNING! Remote key ignored. Bad HTTP status`);
			return '';
		}
		return response.text();
	})
	.catch(error => {
		console.log(`WARNING! Remote key ignored. ${error.message}`);
		return '';
	});
}

async function fetchDisableUserProfile(url, options) {
	options['cache'] = 'no-store';
	return fetch(url, options)
	.then((response) => {
		if (response.status >= 400) {
			console.log(`WARNING! Profile is not blocked. Bad HTTP status`);
			return false;
		} else {
			console.log(`Access is blocked successfully`);
			return true;
		}
	})
	.catch(error => {
		console.log(`WARNING! Error while blocking. ${error.message}`);
		return false;
	});
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Section: Parse source XML file and generate HTML file
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function parseXml(s) {
		const xml = (new DOMParser()).parseFromString(s, "text/xml");
		const parser = new DOMParser();
		const contextNode = parser.parseFromString(s, "text/xml");
		const xpEvaluator = new XPathEvaluator();
		const nsResolver = xpEvaluator.createNSResolver(contextNode.ownerDocument === null ? contextNode.documentElement : contextNode.ownerDocument.documentElement);
		const json = {
			config: {
					title: PRODUCT_NAME,
					favicon: ICON_144X144_DATA_URL,
					subject: '',
					validityNotBefore: '',
					validityNotAfter: '',
					remoteOptions: {},
					privateKey: null,
					keyFormat: null,
					algName: null,
					algEcNamedCurve: null,
					algRsaModulusLength: null,
					algRsaHash: null,
					hashAlg: null,
					stunUrls: [],
					attributes: []
				},
			users: {},
			resources: {}
		};
		//
		let node;
		let xpathResult
		//
	    xpathResult = xml.evaluate('wallet', xml, nsResolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);
	    node = xpathResult.iterateNext();

		const title = node.getAttribute('title');
		if (title !== null)
			json.config.title = title.trim();

		const favicon = node.getAttribute('favicon');
		if (favicon !== null)
			json.config.favicon = favicon.trim();

		const subject = node.getAttribute('subject');
		if (subject !== null)
			json.config.subject = subject.trim();

		const validityNotBefore = node.getAttribute('validityNotBefore');
		if (validityNotBefore !== null)
			json.config.validityNotBefore = validityNotBefore.trim();

		const validityNotAfter = node.getAttribute('validityNotAfter');
		if (validityNotAfter !== null)
			json.config.validityNotAfter = validityNotAfter.trim();

	    const stunUrlsStr = node.getAttribute('stunUrl');
		if (stunUrlsStr !== null) {
			const stunUrls = stunUrlsStr.split(/(\s+)/).filter( e => e.trim().length > 0)
			json.config.stunUrls.push(...stunUrls);
		}

		const privateKeyElements = node.getElementsByTagName('privateKey');
		if (privateKeyElements.length != 0) {
			const privateKeyElement = privateKeyElements[0];

			json.config.privateKey = privateKeyElement.textContent.trim();
			json.config.keyFormat = privateKeyElement.getAttribute('keyFormat');
			json.config.algName = privateKeyElement.getAttribute('algName');
			json.config.algEcNamedCurve = privateKeyElement.getAttribute('algEcNamedCurve');
			json.config.algRsaModulusLength = privateKeyElement.getAttribute('algRsaModulusLength');
			json.config.algRsaHash = privateKeyElement.getAttribute('algRsaHash');
			json.config.hashAlg = privateKeyElement.getAttribute('hashAlg');
		}

		xpathResult = xml.evaluate('wallet/attributes/*', xml, nsResolver, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
		let attributeNode;
		while (attributeNode = xpathResult.iterateNext()) {
			const id = attributeNode.getAttribute('id');
			const label = attributeNode.getAttribute('label');
			let type = attributeNode.getAttribute('type');
			if (type === null)
				type = 'text';
			json.config.attributes.push({id: id, type: type, label: label});
		}

		xpathResult = xml.evaluate('wallet/actions/*', xml, nsResolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);
		let actionNode;
		while (actionNode = xpathResult.iterateNext()) {
			let options;
			const optionsStr = actionNode.textContent.trim();
			if (optionsStr == '')
				options = {};
			else
				options = JSON.parse(optionsStr);
			const requestAction = actionNode.getAttribute('name');
			const url = actionNode.getAttribute('url');
			json.config.remoteOptions[requestAction] = {url: url, options: options};
		}

	    xpathResult = xml.evaluate('wallet/users/*', xml, nsResolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);
		while (node = xpathResult.iterateNext()) {
			const remoteOptions = {};
			for (const childNode of node.childNodes) {
				if (childNode.nodeName != 'actions')
					continue;
				const actionsNode = childNode;
				for (const actionNode of actionsNode.childNodes) {
					if (actionNode.nodeName != 'action')
						continue;
					let options;
					const optionsStr = actionNode.textContent.trim();
					if (optionsStr == '')
						options = {};
					else
						options = JSON.parse(optionsStr);
					const requestAction = actionNode.getAttribute('name');
					const url = actionNode.getAttribute('url');
					remoteOptions[requestAction] = {url: url, options: options};
				}
			}

			const attributes = {};
			for (const childNode of node.childNodes) {
				if (childNode.nodeName != 'attributes')
					continue;
					const attributesNode = childNode;
					for (const attributeNode of attributesNode.childNodes) {
						if (attributeNode.nodeName != 'attribute')
							continue;
						const id = attributeNode.getAttribute('id');
						const value = attributeNode.getAttribute('value');
						attributes[id] = value;
				  }
			}
			const username = node.getAttribute('username');
			const obj = {};
			json.users[username] = obj;
			obj['attributes'] = attributesValuesToString(json.config.attributes, attributes);
			obj['password'] = node.getAttribute('password');
			obj['remoteBlockPassword'] = node.getAttribute('remoteBlockPassword');
			obj['hash'] = node.getAttribute('hash');
			obj['reg'] = node.getAttribute('reg');
			obj['ip'] = node.getAttribute('ip');
			obj['remoteAuthorization'] = node.getAttribute('remoteAuthorization');
			obj['remoteOptions'] = remoteOptions;
			obj['remoteSecret'] = node.getAttribute('remoteSecret');
			obj['sessionTimeoutSec'] = parsePositiveInt(node.getAttribute('sessionTimeoutSec'));
			obj['sessionTimeoutWarningSec'] = parsePositiveInt(node.getAttribute('sessionTimeoutWarningSec'));
		}
		//
	    xpathResult = xml.evaluate('wallet/resources/*', xml, nsResolver, XPathResult.UNORDERED_NODE_ITERATOR_TYPE, null);
	    while (node = xpathResult.iterateNext()) {
	    	  const obj = {};
	    	  obj['title'] = node.getElementsByTagName('title')[0].textContent.trim();
	    	  obj['description'] = node.getElementsByTagName('description')[0].textContent.trim();
			  const dataEl = node.getElementsByTagName('data')[0];
			  if (dataEl !== undefined) {
				  //
				  const resourcePassword = dataEl.getAttribute('password');
		    	  if (resourcePassword !== null)
			    		obj['password'] = resourcePassword.trim();
		    	  //
				  const vernamKey = dataEl.getAttribute('vernamKey');
		    	  if (vernamKey !== null)
			    		obj['vernamKey'] = vernamKey.trim();
				  //
				  const self = dataEl.getAttribute('self');
				  if (self === 'true') {
						obj['self'] = true;
						obj['data'] = s;
				  } else
				  	obj['data'] = dataEl.textContent.trim();
			  }
	    	  let usersEl = node.getElementsByTagName('users')[0];
	    	  if (usersEl !== undefined) {
	    	  		let users = usersEl.children;
	    	  		obj['users'] = [];
	    	  		for(const user of users) {
	    	  			const resUsername = user.getAttribute('username');
	    	  			if (json.users[resUsername] === undefined)
	    	  				console.error(`ERROR: Unknown username: '${resUsername}'`);
	    				obj['users'].push(resUsername);
	    	  		}
	    	  }
	    	  let id = node.getAttribute('id');
			  if (id === null)
				  id = MurmurHashV3(obj['title']);

	    	  json.resources[id] = obj;
	    }
		return json;
}

function attributesValuesToString(configAttributes, attributes) {
	  const sortedAttributes = [];
	  for (const attributeObj of configAttributes) {
		  const id = attributeObj.id;
		  sortedAttributes.push({id: id, value: attributes[id]}); 
	  }
	  let attributesStr = '';
	  let first = true;
	  for (const attributeObj of sortedAttributes) {
		  if (first)
			  first = false;
		  else
			  attributesStr += '\0';
		  let attrValue = attributeObj.value;
		  if (attrValue === undefined || attrValue === null)
			  attrValue = '';
		  attributesStr += attrValue;
	  }
	  return attributesStr;
}

	async function createEmptyWallet() {
		const xml =  document.getElementById('xml').innerHTML;
		await generate(xml, true, true);
	}

	function handleFileSelect(event) {
		inputFileEl.removeEventListener('change', handleFileSelect);
		const reader = new FileReader()
		reader.onload = handleFileLoad;
		xmlFile = event.target.files[0];
		console.info(`INFO: Process source file: ${xmlFile.name} Last modified (UNIX Time): ${xmlFile.lastModified}`);
		reader.readAsText(xmlFile);
		inputFileEl.value = ''; // https://stackoverflow.com/questions/9155136/chrome-file-upload-bug-on-change-event-wont-be-executed-twice-with-the-same-fi
	}

	async function handleFileLoad(event) {
		xml = event.target.result;
		await generate(xml, false, true);
	}

	async function getTheFile() {
		inputFileEl.addEventListener('change', handleFileSelect);
		inputFileEl.click();
	}

	function getHTML() {
		let outerHTML = document.documentElement.outerHTML;
		outerHTML = '<!DOCTYPE html>\n' + outerHTML;
		return outerHTML.trim();
	}

async function generate(xml, empty, download) {
		const json = parseXml(xml);

		let encryptedJson = await generateEncryptedJson(json);

		// save
		const savedUuid = metaContainerUuidEl.getAttribute('content');
		const savedEncryptedJsonStr = jsonHolder.textContent;
		const savedRootElInnerHtml = rootEl.innerHTML;
		const savedAppName = appName.textContent;
		const wasLogIn = userNameText.textContent != '';
		const savedUserName = userNameText.textContent;
		const savedDigest = metaSha256El.getAttribute('content');
		const savedMetaSignature = metaSignatureEl.getAttribute('content');
		const savedShowIntegrityTestErrorMessage = integrityTestErrorMessage.style.display == 'block';

		// generate
		const encryptedJsonStr = empty ? '' : JSON.stringify(encryptedJson);
		const generatedSha256 = empty ? ZERO_SHA_256 : await digestMessage(encryptedJsonStr);
		const generatedSize = encryptedJsonStr.length;
		const generatedUuid = empty ? ZERO_UUID : uuidv4();

		metaContainerUuidEl.setAttribute('content', generatedUuid);
		metaEncryptedDataSizeEl.setAttribute('content', generatedSize);
		metaSignatureEl.setAttribute('content', '');
		jsonHolder.textContent =  encryptedJsonStr;
		inactivityMessage.style.display = 'none';
		integrityTestOkMessage.style.display = 'none';
		integrityTestErrorMessage.style.display = 'none';
		statusMessageMargin.style.display = 'none';
		btnSignIn.style.display = empty ? 'none' : 'flex';
		mnuInstall.style.display = empty ? 'block' : 'none';
		document.title = '';
		userComponent.style.display = 'none';
		userNameText.textContent = '';
		appName.textContent = '';
		rootEl.innerHTML = '';
		logo.src = ''
		tdUuid.innerHTML = '';
		tdSha256.innerHTML = '';
		tdSize.innerHTML = '';
		tdVersion.innerHTML = '';
		tdWmk.innerHTML = '';
		tdSubject.innerHTML = '';
		tdValidityNotBefore.innerHTML = '';
		tdValidityNotAfter.innerHTML = '';

		const linkManifestEl = headEl.querySelector('link[rel="manifest"]');
		if (linkManifestEl != null)
			headEl.removeChild(linkManifestEl);

		const linkIconEl = headEl.querySelector('link[rel="icon"]');
		if (linkIconEl != null)
			linkIconEl.href = '';

		const fileName = empty ? FILE_NAME : generatedUuid + '.html';

		const pemPrivateKey = json.config.privateKey;
		if (pemPrivateKey === null || empty) {
			metaSha256El.setAttribute('content', '');
			metaSha256El.setAttribute('content', await digestMessage(getHTML()));

			if (download)
				downloadAsHtmlFile(fileName, getHTML());
			// restore
			mnuInstall.style.display = WAS_EMPTY ? 'block' : 'none';
			integrityTestErrorMessage.style.display = savedShowIntegrityTestErrorMessage ? 'block' : 'none';
			appName.textContent = savedAppName;
			metaContainerUuidEl.setAttribute('content', savedUuid);
			rootEl.innerHTML = savedRootElInnerHtml;
			jsonHolder.textContent = savedEncryptedJsonStr;
			if (wasLogIn) {
				btnSignIn.style.display = 'none';
				userComponent.style.display = 'flex';
				userNameText.textContent = savedUserName;
			} else
				btnSignIn.style.display = WAS_EMPTY ? 'none' : 'flex';
			metaSha256El.setAttribute('content', savedDigest);
			metaSignatureEl.setAttribute('content', savedMetaSignature);
		} else {
			const keyFormat = json.config.keyFormat;
			const algName   = json.config.algName;
			const algEcNamedCurve  = json.config.algEcNamedCurve;
			const algRsaModulusLength = json.config.algRsaModulusLength;
			const algRsaHash = json.config.algRsaHash;
			const hashAlg = json.config.hashAlg; 

			metaSha256El.setAttribute('content', '');
			metaSignatureEl.setAttribute('content', '');
			await signMsg(keyFormat, algName, algEcNamedCurve, algRsaModulusLength, algRsaHash, hashAlg, pemPrivateKey, getHTML(), (pemSignature) => {
				metaSignatureEl.setAttribute('content', pemSignature);
				digestMessage(getHTML()).then(digest => {
					metaSha256El.setAttribute('content', digest);
					if (download)
						downloadAsHtmlFile(fileName, getHTML());
					// restore
					integrityTestErrorMessage.style.display = savedShowIntegrityTestErrorMessage ? 'block' : 'none';
					appName.textContent = savedAppName;
					metaContainerUuidEl.setAttribute('content', savedUuid);
					rootEl.innerHTML = savedRootElInnerHtml;
					jsonHolder.textContent = savedEncryptedJsonStr;
					if (wasLogIn) {
						btnSignIn.style.display = 'none';
						userComponent.style.display = 'flex';
						userNameText.textContent = savedUserName;
					} else
						btnSignIn.style.display = WAS_EMPTY ? 'none' : 'flex';	
					metaSha256El.setAttribute('content', savedDigest);
					metaSignatureEl.setAttribute('content', savedMetaSignature);
					});
			});
		}
}
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

async function generateEncryptedJson(json) {
    const outJson = JSON.parse(MIN_ENCRYPTED_JSON_STR);
    outJson.config['title'] = json.config['title'];
    outJson.config['favicon'] = json.config['favicon'];
    outJson.config['stunUrls'] = json.config['stunUrls'];
    outJson.config['remoteOptions'] = json.config['remoteOptions'];
    outJson.config['subject'] = json.config['subject'];
    outJson.config['validityNotBefore'] = json.config['validityNotBefore'];
    outJson.config['validityNotAfter'] = json.config['validityNotAfter'];

    outJson.config['attributes'] = json.config['attributes'];
	//
    for (const [resourceId, resource] of Object.entries(json['resources'])) {
        const id = bs2s(getRandomBytes(ID_LENGTH));
        resource['resAesKey'] = bs2s(resource['users'] === undefined ? STANDARD_KEY : getRandomBytes(KEY_LENGTH));
		//
        const resourcePassword = resource['password'];
        let resEntryEncrypted = resourcePassword !== undefined;
		//
		let resourceVernamKey = resource['vernamKey'];
        let resEntryVernamed = resourceVernamKey !== undefined;
		//
        let data = resource['data'];
		//
        if (resEntryEncrypted)
            data = await aesGcmEncrypt(data, new TextEncoder().encode(resourcePassword));
        // process with Vernam
        if (resEntryVernamed) {
        	resourceVernamKey = normalize(resourceVernamKey);
        	if(data.length > resourceVernamKey)
        		alert(`Error: Vernam key too short, required min: ${data.length}`);
        	else {
        		if (resourceVernamKey.length > data.length)
        			resourceVernamKey = resourceVernamKey.substring(0, data.length);
        	}
            data = xorStrings(data, resourceVernamKey);
        }
        let resEntryJsonStr = JSON.stringify({resource: {title: resource['title'], description: resource['description'], self: resource['self'], encrypted: resEntryEncrypted, vernamed: resEntryVernamed, data: data}, resourceId: resourceId});
        outJson['res'][id] = await aesGcmEncrypt(resEntryJsonStr, s2bs(resource['resAesKey']));
        if (resource['users'] !== undefined)
            for (const username of resource['users']) {
                if (json['users'][username]['resources'] === undefined)
                    json['users'][username]['resources'] = {};
                const userResources = json['users'][username]['resources'];
                userResources[id] = resource['resAesKey'];
            }
    }
    //
    for (const [username, userObj] of Object.entries(json['users'])) {
		let userResourcesJson = userObj['resources'];
		if (userResourcesJson === undefined)
			userResourcesJson = {};

        const userResourcesJsonStr = JSON.stringify(userResourcesJson);
		//
        const userPassword = userObj['password'];
		const userAttributes = userObj['attributes'];
        const userHash = userObj['hash'];
        const userRegCode = userObj['reg'];
        const userIp = userObj['ip'];
        const password = buildPassword(username, userPassword, userAttributes, userHash, userRegCode, userIp);
        const remoteSecret = userObj['remoteSecret'];
        const remoteAuthorization = userObj['remoteAuthorization'];
        const remoteOptions = userObj['remoteOptions'];
        const sessionTimeoutSec	    	= userObj['sessionTimeoutSec'];
       	const sessionTimeoutWarningSec  = userObj['sessionTimeoutWarningSec'];
		//
		const remoteOptionsStr = JSON.stringify(remoteOptions);

		const sessionObj = {
							sessionTimeoutSec: sessionTimeoutSec,
							sessionTimeoutWarningSec: sessionTimeoutWarningSec
							};
        const sessionObjStr = JSON.stringify(sessionObj);
		//
		const remoteBlockPassword = userObj['remoteBlockPassword'];
        if (remoteBlockPassword !== null) {
        	const passwordToBlock = buildPassword(username, remoteBlockPassword);
        	outJson['dlt'].push(await aesGcmEncrypt(remoteOptionsStr, passwordToBlock));
        }
        //
        if (userIp !== null)
        	outJson['ips'].push(await aesGcmEncrypt(userIp, password));
        //
        outJson['rmt'].push(await aesGcmEncrypt(remoteOptionsStr, password));
        const passwordRemote = buildPassword(username, userPassword, userAttributes, userHash, userRegCode, userIp, remoteSecret);
        //
        outJson['usr'].push(await aesGcmEncrypt(userResourcesJsonStr, passwordRemote));
        outJson['ses'].push(await aesGcmEncrypt(sessionObjStr, passwordRemote));
    }
    return outJson;
}

function buildPassword(userName, userPassword, userAttributes, userHash, userRegCode, userIp, remoteSecret) {
    if (userPassword === undefined || userPassword === null)
    	userPassword = '';
    if (userAttributes === undefined || userAttributes === null)
    	userAttributes = '';
    if (userHash === undefined || userHash === null)
    	userHash = '';
	if (userRegCode === undefined || userRegCode === null)
		userRegCode = '';
	if (userIp === undefined || userIp === null)
    	userIp = '';
    if (remoteSecret === undefined || remoteSecret === null)
    	remoteSecret = '';
    console.log((userPassword.trim() + '\0' + userAttributes + '\0' + userName.trim() + '\0' + userIp.trim() + '\0' + userHash.trim() + '\0' + userRegCode.trim() + '\0' + remoteSecret));
	return new TextEncoder().encode(userPassword.trim() + '\0' + userAttributes + '\0' + userName.trim() + '\0' + userIp.trim() + '\0' + userHash.trim() + '\0' + userRegCode.trim() + '\0' + remoteSecret);
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

async function extractPublicData(encryptedJson) {
	const resEntryJsons = [];
	if (encryptedJson['res'] === undefined)
		return resEntryJsons;
    for (const encResData of Object.values(encryptedJson['res'])) {
            const resEntryJsonStr = await aesGcmDecrypt(encResData, s2bs(bs2s(STANDARD_KEY)));
            if (resEntryJsonStr === null)
                continue;
            const resEntryJson = JSON.parse(resEntryJsonStr);
            const resourceId = resEntryJson['resourceId'];
       		resEntryJsons.push(resEntryJson);
    }
    return resEntryJsons;
}

async function extractPrivateData(encryptedJson, userName, userPassword, userAttributes, userHash, userRegCode, userIp, resEntryJsons) {
    const ips = encryptedJson['ips'];
    let checkedIp = null;
    let password = buildPassword(userName, userPassword, userAttributes, userHash, userRegCode, userIp);
    for(const encIp of ips) {
    	checkedIp = await aesGcmDecrypt(encIp, password);
        if (checkedIp !== null && checkedIp === userIp)
            break;
    }
    password = buildPassword(userName, userPassword, userAttributes, userHash, userRegCode, checkedIp);
    //
    const rmts = encryptedJson['rmt'];
	//
    let remoteOptionsStr = null;
    for(const rmt of rmts) {
    	remoteOptionsStr = await aesGcmDecrypt(rmt, password);
        if (remoteOptionsStr !== null) {
    		remoteOptions = JSON.parse(remoteOptionsStr);
            break;
        }
    }
    //
    const sess = encryptedJson['ses'];
	//
    let sessionObjStr = null;
    for(const ses of sess) {
    	sessionObjStr = await aesGcmDecrypt(ses, password);
        if (sessionObjStr !== null)
            break;
    }
    if (sessionObjStr !== null) {
    	const sessionObj = JSON.parse(sessionObjStr);
        sessionTimeoutSec = sessionObj.sessionTimeoutSec;
        sessionTimeoutWarningSec = sessionObj.sessionTimeoutWarningSec;
		if (sessionTimeoutSec < sessionTimeoutWarningSec)
			sessionTimeoutSec = sessionTimeoutWarningSec;
    }

    let remoteSecret;
    if (remoteOptions !== null)
    	remoteSecret = await fetchRemoteSecret(remoteOptions['get-remote-secret']['url'], remoteOptions['get-remote-secret']['options']);
	//
    const passwordRemote = buildPassword(userName, userPassword, userAttributes, userHash, userRegCode, checkedIp, remoteSecret);

	let ok = false;
    const usrEncs = encryptedJson['usr'];
    for (const enc of usrEncs) {
        const userResourcesJsonStr = await aesGcmDecrypt(enc, passwordRemote);
        if (userResourcesJsonStr === null)
            continue;
        ok = true;
        const userResourcesJson = JSON.parse(userResourcesJsonStr);
        for (const [resId, resAesKey] of Object.entries(userResourcesJson)) {
            const encResData = encryptedJson['res'][resId];
            const resEntryJsonStr = await aesGcmDecrypt(encResData, s2bs(resAesKey));
            const resEntryJson = JSON.parse(resEntryJsonStr);
            const resourceId = resEntryJson['resourceId'];
      		resEntryJsons.push(resEntryJson);
        }
    }
    return ok;
}

async function blockUserIfNeeded(encryptedJson, userName, userPassword) {
    const dlts = encryptedJson['dlt'];
    for(const dlt of dlts) {
    	const passwordToBlock = buildPassword(userName, userPassword);

    	const remoteOptionsStr = await aesGcmDecrypt(dlt, passwordToBlock);
	    if (remoteOptionsStr !== null) {
    		const remoteOptions = JSON.parse(remoteOptionsStr);
    		const remoteSecret = await fetchRemoteSecret(remoteOptions['get-remote-secret']['url'], remoteOptions['get-remote-secret']['options']);
    		return await fetchDisableUserProfile(remoteOptions['disable-user-profile']['url'], remoteOptions['disable-user-profile']['options']);
    	}
    }
    return false;
}

async function mapResources(query, resEntryJsons) {
    const map = {};

    for (const resEntryJson of resEntryJsons) {
        const resourceId = resEntryJson['resourceId'];
        const resource = resEntryJson['resource'];
        map[resourceId] = resource;
    }
    if (query.length == 0)
    	return map;

    const m = {};
    for (const resourceId of query) {
        const resource = map[resourceId];
        if (resource !== undefined)
        	m[resourceId] = resource;
    }
    return m;
}

function createResourceElement(resourceId, resource) {
	const temp = document.getElementById("res-template");
	const resMainT = temp.content.querySelector(".res-main");
	const resMainEl = document.importNode(resMainT, true);

	const encrypted = resource['encrypted'];
	const vernamed = resource['vernamed'];

	let resourceData = resource['data'];
	let resourceSelf = resource['self'];

	const resInfo = resMainEl.querySelector(".res-info");

	const resIdRowEl = resInfo.querySelector(".res-id-row");
	const resIdEl = resIdRowEl.querySelector(".res-id");
	const resNameEl = resInfo.querySelector(".res-name");
	const resDescriptionEl = resInfo.querySelector(".res-description");

	const resLock = resIdRowEl.querySelector(".res-lock");
	resLock.style.visibility = encrypted || vernamed ? 'visible': 'hidden';

	const resContentEl = resMainEl.querySelector(".res-content");
	resContentEl.setAttribute('data-resource-id', resourceId);
	
	const permalinkUrl = window.location.origin + window.location.pathname + '?' + resourceId;
	resIdEl.href = permalinkUrl;
	resIdEl.textContent = resourceId;
 	resIdEl.addEventListener('click', (e) => {
 		e.stopPropagation();
 	});

	resNameEl.textContent = resource['title'];
	resDescriptionEl.textContent = resource['description'];
    if (resourceSelf)
    	resInfo.setAttribute('data-resource-self', resourceSelf);
    resInfo.setAttribute('data-resource-id', resourceId);
    resInfo.setAttribute('data-resource-content', resourceData);
    resInfo.setAttribute('data-resource-encrypted', encrypted);
    resInfo.setAttribute('data-resource-vernamed', vernamed);
    resInfo.setAttribute('data-mode', 'on');
    resInfo.addEventListener('click', (e)=> {
    	const resInfo = e.currentTarget;
       	let mode = resInfo.getAttribute('data-mode');
       	if (mode == 'on') {

       		const resourceId = resInfo.getAttribute('data-resource-id');
       		let resourceSelf = resInfo.getAttribute('data-resource-self') === 'true';
        	let resourceData = resInfo.getAttribute('data-resource-content');
           	let encrypted = resInfo.getAttribute('data-resource-encrypted') === 'true';
           	let vernamed = resInfo.getAttribute('data-resource-vernamed') === 'true';
            if (encrypted || vernamed) {
                decryptForm.setAttribute('data-resource-id', resourceId);
                decryptForm.setAttribute('data-resource-self', resourceSelf);
                decryptForm.setAttribute('data-resource-content', resourceData);

                vernamKeyTextArea.style.setProperty('-webkit-text-security', 'disc');
        		if (encrypted) {
        			decryptPasswordInputLabel.classList.add('required');
        			decryptPasswordInput.setAttribute('required', '');
        			decryptPasswordInputLabel.style.display = 'inline-block';
        			decryptPasswordInput.style.display = 'inline-block';
					decryptShowPassword.style.display = 'inline-block';
					decryptShowPasswordLabel.style.display = 'inline-block';
        		} else {
        			decryptPasswordInputLabel.style.display = 'none';
        			decryptPasswordInput.style.display = 'none';
					decryptShowPassword.style.display = 'none';
					decryptShowPasswordLabel.style.display = 'none';
        		}
        		if (vernamed) {
        			vernamKeyTextAreaLabel.classList.add('required');
        			vernamKeyTextArea.setAttribute('required', '');
        			vernamKeyTextAreaLabel.style.display = 'inline-block';
        			vernamKeyTextArea.style.display = 'inline-block';
					decryptShowVernamKey.style.display = 'inline-block';
					decryptShowVernamKeyLabel.style.display = 'inline-block';
        		} else {
        			vernamKeyTextAreaLabel.style.display = 'none';
        			vernamKeyTextArea.style.display = 'none';
					decryptShowVernamKey.style.display = 'none';
					decryptShowVernamKeyLabel.style.display = 'none';
        		}

                decryptDialog.addEventListener('keydown', e => {
              	  if (e.key === 'Escape')
              		  decryptDialog.dispatchEvent(new Event('cancel'))
              	});
                decryptForm.addEventListener('submit', async (e)=> {
            		e.preventDefault();
            		const decryptForm = e.currentTarget;
            		const resourceId = decryptForm.getAttribute('data-resource-id');
            		const resourceSelf = decryptForm.getAttribute('data-resource-self') === 'true';

            		let resourceData = decryptForm.getAttribute('data-resource-content');

            		let resourceVernamKey = vernamKeyTextArea.value;
                	resourceVernamKey = normalize(resourceVernamKey);
   		        	if (resourceVernamKey.length > resourceData.length)
   		        		resourceVernamKey = resourceVernamKey.substring(0, resourceData.length);

            		// process with Vernam
       		        if (resourceVernamKey.length == resourceData.length)
  		        		resourceData = xorStrings(resourceData, resourceVernamKey);

            		const rd = await aesGcmDecrypt(resourceData, new TextEncoder().encode(decryptPasswordInput.value.trim()));
            		if (rd !== null) {
            			if (resourceSelf)
            				openXml(rd);
            			else {
            				const resContentEl = document.querySelector('.res-content[data-resource-id="' + resourceId + '"]');
            				dataToHtml(resContentEl, rd);
            				resInfo.setAttribute('data-mode', 'off');
            				resContentEl.style.display = 'block';
            			}
            			clearDecryptDialog();
            			decryptDialog.close();
            		} else
            			decryptErrorMsg.style.visibility = 'visible';
            	});
            	decryptDialog.showModal();
            } else {
    			if (resourceSelf)
    				openXml(resourceData);
    			else {
    				const resContentEl = document.querySelector('.res-content[data-resource-id="' + resourceId + '"]');
	            	dataToHtml(resContentEl, resourceData);
	    			resInfo.setAttribute('data-mode', 'off');
	    			resContentEl.style.display = 'block';
    			}
            }
        } else {
        	const resContentEl = document.querySelector('.res-content[data-resource-id="' + resourceId + '"]');
        	resContentEl.innerHTML = '';
        	resInfo.setAttribute('data-mode', 'on');
        	resContentEl.style.display = 'none';
       	}
    });
	return resMainEl;
}

async function dataToHtml(el, data) {
	if (data.startsWith('<')) {
		el.innerHTML = '<div>' + data + '</div>';
	} else if (data.startsWith('https://') || data.startsWith('http://') || data.startsWith('mailto:') || data.startsWith('tel:')) {
		const rootEl = document.createElement('div');
		rootEl.classList.add('res-content-root');
		el.appendChild(rootEl);

		const aEl = document.createElement('a');
		aEl.setAttribute('href', data);
		aEl.innerHTML = data;
		rootEl.appendChild(aEl);

		const qrCodeEl = createQr(data);

		const borderedSpacForQrCodeEl = document.createElement('div');
		borderedSpacForQrCodeEl.classList.add('bordered-space');
		borderedSpacForQrCodeEl.appendChild(qrCodeEl);
		rootEl.appendChild(borderedSpacForQrCodeEl);
	} else if (data.startsWith('data:image/')) {
		el.innerHTML = '<img src="' + data + '">';
	} else if (data.startsWith('otpauth://totp/')) {
    	const promise = getTotpCode(data);
		promise.then((code) => {
			const rootEl = document.createElement('div');
			rootEl.classList.add('res-content-root');
			el.appendChild(rootEl);

			const codeEl = document.createElement('div');
			codeEl.classList.add('totp-code');
			codeEl.textContent = code;
			rootEl.appendChild(codeEl);

			const borderedSpacForTotpUrlEl = document.createElement('div');
			borderedSpacForTotpUrlEl.classList.add('bordered-space');

			const urlEl = document.createElement('div');
			urlEl.classList.add('totp-link');
			urlEl.innerHTML = data;
			urlEl.style.opacity = '0';
			borderedSpacForTotpUrlEl.appendChild(urlEl);

			const borderedSpacForQrCodeEl = document.createElement('div');
			borderedSpacForQrCodeEl.classList.add('bordered-space');

			const qrCodeEl = createQr(data);
			qrCodeEl.style.opacity = '0';
			borderedSpacForQrCodeEl.appendChild(qrCodeEl);

			rootEl.appendChild(borderedSpacForTotpUrlEl);
			rootEl.appendChild(borderedSpacForQrCodeEl);

			const checkboxHolderEl = document.createElement('span');
			checkboxHolderEl.classList.add('totp-checkbox-holder');
			rootEl.appendChild(checkboxHolderEl);

			const checkboxId = uuidv4();
			const checkboxEl = document.createElement('input');
			checkboxEl.setAttribute('id', checkboxId);
			checkboxEl.setAttribute('type', 'checkbox');
			checkboxEl.addEventListener('change', (e) => {
				const opacity = e.currentTarget.checked ? '1' : '0';
				qrCodeEl.style.opacity = opacity;
				urlEl.style.opacity = opacity;
			});
			checkboxHolderEl.appendChild(checkboxEl);

			const checkboxLabelEl = document.createElement('label');
			checkboxLabelEl.setAttribute('for', checkboxId);
			checkboxHolderEl.classList.add('label');
			checkboxLabelEl.innerHTML = 'Show otpauth URI';
			checkboxHolderEl.appendChild(checkboxLabelEl);
		});
	} else {
		el.innerHTML = '<pre>' + data + '</pre>';
	}
}

function createQr(data) {
	const qrCodeEl = document.createElement('div');
	qrCodeEl.classList.add('qr-code');

	const typeNumber = 0;
	const errorCorrectionLevel = 'L';
	const qr = qrcode(typeNumber, errorCorrectionLevel);
	qr.addData(data);
	qr.make();
	qrCodeEl.innerHTML = qr.createSvgTag(3, 0, '', '', 'black'); // cellSize, margin, alt, title, color
	return qrCodeEl;
}

async function getTotpCode(url) {
	let totp = {
			issuer0: null,
			account: null,
			secret: null,
			issuer: null,
			algorithm: 'SHA1',
			digits: 6,
			period: 30
		};
		let urlWithoutPrefix = url.substring('otpauth://totp/'.length);
		let pos = urlWithoutPrefix.indexOf(':');
		totp.issuer0 = decodeURIComponent(urlWithoutPrefix.substring(0, pos));
		let pos2 = urlWithoutPrefix.indexOf('?');
		totp.account = urlWithoutPrefix.substring(pos + 1, pos2);
		let paramsString = urlWithoutPrefix.substring(pos2 + 1);
		const searchParams = new URLSearchParams(paramsString);
		totp.secret = searchParams.get('secret');
		totp.issuer = searchParams.get('issuer');

		const algorithm = searchParams.get('algorithm');
		if (algorithm !== null)
			totp.algorithm = algorithm;
		const digits = searchParams.get('digits');
		if (digits !== null)
			totp.digits = parseInt(digits);
		
		const period = searchParams.get('period');
		if (period !== null)
			totp.period = parseInt(period);
		const totpGen = new TOTP(totp.secret, totp.digits);
		return totpGen.gen(totp.period);
}

async function displayResults(parentEl, map) {
	const entries = Object.entries(map);
	entries.sort(function(e1,e2) {
    	return e1[1].title.localeCompare(e2[1].title);
	});
	parentEl.innerHTML = '';
	let first = true;
    for (const [resourceId, resource] of entries) {
        const resourceEl = createResourceElement(resourceId, resource);
        parentEl.appendChild(resourceEl);
    }
    document.body.scrollTo(0, 0);
}

async function draw(encryptedJson, query, user, password, attributes, hash, regCode, ip) {
	const dlt = await blockUserIfNeeded(encryptedJson, user, password);
	if (dlt) {
	    let map = await mapResources(query, resEntryJsonsPublic);
	    displayResults(rootEl, map);
	    return false;
	}
	let resEntryJsons = [...resEntryJsonsPublic];
	const ok = await extractPrivateData(encryptedJson, user, password, attributes, hash, regCode, ip, resEntryJsons);
    if (!ok)
    	return false;
    let map = await mapResources(query, resEntryJsons);
    displayResults(rootEl, map);
    return true;
}

async function displayWallet() {
	if (WAS_EMPTY) {
		size = 0;
		sha256 = ZERO_SHA_256;
		subject = ZERO_SUBJECT;
		validityNotBefore = '';
		validityNotAfter = '';
	} else {
		size = encryptedJsonStr.length;
		sha256 = await digestMessage(encryptedJsonStr);
		subject = config.subject;
		validityNotBefore = config.validityNotBefore;
		validityNotAfter = config.validityNotAfter;
	}

    const usrEncs = encryptedJson['usr'];
    hasUsers = usrEncs.length != 0;
    if (hasUsers)
    	btnSignIn.style.display = 'flex';

    if (config.remoteOptions['event-open'] !== undefined)
    	await fetchLog(config.remoteOptions['event-open']['url'], config.remoteOptions['event-open']['options']);

    /* set title */
    document.title = config.title;
	appName.textContent = config.title;

	/* set favicon */
	favicon.href = config.favicon;

	let start_url;
	let name;
	let description;
	let icon_data_url;

    let stunUrls = config['stunUrls'];
    let ip = '';
	if (stunUrls !== undefined && stunUrls.length != 0)
		ip = await getIp(stunUrls);

    resEntryJsonsPublic = await extractPublicData(encryptedJson);
    mapPublic = await mapResources(query, resEntryJsonsPublic);
    displayResults(rootEl, mapPublic);

    btnSignIn.addEventListener('click', (e)=> {
    	let attributes = config['attributes'];
    	for (const attributeObj of attributes) {
    		const id = attributeObj.id;
    		const type = attributeObj.type;
    		const label = attributeObj.label;
    		const attrLabelEl = document.createElement('label');
    		attrLabelEl.textContent = label + ':'; 
    		attrLabelEl.setAttribute('for', 'attribute.' + id);
    		attrLabelEl.classList.add('label', 'dialogLabel');
    		attributesDetailsHolder.appendChild(attrLabelEl);
    		const attrInputEl = document.createElement('input');
    		attributesDetailsHolder.appendChild(attrInputEl);
    		attrInputEl.setAttribute('id', 'attribute.' + id);
    		attrInputEl.setAttribute('data-id', id);
    		attrInputEl.setAttribute('type', type);
    		attrInputEl.setAttribute('placeholder', 'Enter ' + label);
    		attrInputEl.setAttribute('autocomplete', 'off');
    	}
    	loginDialog.showModal();
    });

	mnuBlock.addEventListener('click', (e)=> {
		if (!mnuBlock.classList.contains('menu-item-disabled'))
    		blockDialog.showModal();
    });
	mnuSignOut.addEventListener('click', (e)=> {
		signOut();
		menuRight.style.display = 'none';
    });

	addStatusMessagesCancelListeners();

    addDialogsCancelListeners(loginDialog, clearLoginDialog);
    addDialogsCancelListeners(aboutDialog);
    addDialogsCancelListeners(registerDialog, clearRegisterDialog);
    addDialogsCancelListeners(unregisterDialog);
    addDialogsCancelListeners(blockDialog, clearBlockDialog);
    addDialogsCancelListeners(decryptDialog, clearDecryptDialog);

    loginDialog.addEventListener('keydown', e => {
    	  if (e.key === 'Escape') {
      		loginDialog.close();
   	    	clearLoginDialog();
    	  }
    });
    loginForm.addEventListener('submit', async (e)=> {
    	e.preventDefault();
    	const attributes = {};
    	const inputs = attributesDetailsHolder.querySelectorAll('input');
    	for (const input of inputs) {
    		const id = input.getAttribute('data-id');
    		attributes[id] = input.value.trim();
    	}
    	const attributesStr = attributesValuesToString(config.attributes, attributes);
    	const user = userInput.value;
    	loggedIn = await draw(encryptedJson, query, user, loginPasswordInput.value, attributesStr, hash, regCode, ip);
    	if (loggedIn) {
    		if (remoteOptions['event-sign-in-succes'] !== null)
    	    	await fetchLog(remoteOptions['event-sign-in-succes']['url'], remoteOptions['event-sign-in-succes']['options']);

    	    if (remoteOptions['disable-user-profile'] === null)
    	    	mnuBlock.classList.add('menu-item-disabled');

    		btnSignIn.style.display = 'none';
    		userComponent.style.display = 'flex';
    		userNameText.textContent = user.trim();
    		loginDialog.close();
    		resetWarningTimer();
   	    	clearLoginDialog();
    	} else {
    	    if (config.remoteOptions['event-sign-in-failed'] !== undefined)
    	    	await fetchLog(config.remoteOptions['event-sign-in-failed']['url'], config.remoteOptions['event-sign-in-failed']['options']);
    		loginErrorMsg.style.visibility = 'visible';
    	}
    });
    //
    blockDialog.addEventListener('keydown', e => {
  	  if (e.key === 'Escape')
  		  blockDialog.dispatchEvent(new Event('cancel'));
	});
	blockForm.addEventListener('submit', async (e)=> {
  		e.preventDefault();

  		const ok =  await fetchDisableUserProfile(remoteOptions['disable-user-profile']['url'], remoteOptions['disable-user-profile']['options']);
  		if (ok) {
  			blockDialog.close();
			signOut();
  		} else
  			blockErrorMsg.style.visibility = 'visible';
	});

	mnuCreateWalletFromSource.addEventListener('click', e => {
		getTheFile();
		menuLeft.style.display = 'none';
	});
	
	mnuCreateEmptyWallet.addEventListener('click', e => {
		createEmptyWallet();
		menuLeft.style.display = 'none';
	});

	if (WAS_EMPTY) {
		mnuInstall.style.display = 'block';
		mnuInstall.addEventListener('click', e => {
			if (!mnuInstall.classList.contains('menu-item-disabled'))
				install();
		});
	}

	mnuAbout.addEventListener('click', (e)=> {
		logo.src = ICON_144X144_DATA_URL;
		tdVersion.innerHTML = PRODUCT_VERSION;
		tdUuid.innerHTML = uuid;
		tdSha256.innerHTML = sha256.substring(0, 36) + '‏‏‎<br>‎' + sha256.substring(36);
		tdSize.innerHTML = size;
		tdWmk.innerHTML = wmk;
		tdSubject.innerHTML = subject;
		tdValidityNotBefore.innerHTML = validityNotBefore;
		tdValidityNotAfter.innerHTML = validityNotAfter;

		aboutDialog.showModal();
		menuLeft.style.display = 'none';
	});

	mnuRegister.addEventListener('click', (e)=> {
		registerDialog.showModal();
		menuLeft.style.display = 'none';
	});

	registerForm.addEventListener('submit', (e)=> {
		const regCode = registerPasswordInput.value.trim();
		if (regCode != '')
			localStorage.setItem('reg-' + uuid, regCode);
		readLocalStorage();
		clearRegisterDialog();
	});

	mnuUnregister.addEventListener('click', (e)=> {
		unregisterDialog.showModal();
		menuLeft.style.display = 'none';
	});
	btnUnregisterOk.addEventListener('click', (e)=> {
		clearLocalStorage();
		readLocalStorage();
		unregisterDialog.close();
	});
}

async function install() {
	menuLeft.style.display = 'none';
	if (beforeinstallpromptEvent !== undefined) {
		beforeinstallpromptEvent.prompt();
		const { outcome } = await beforeinstallpromptEvent.userChoice;
		if (outcome === 'accepted') {
			beforeinstallpromptEvent = undefined;
			mnuInstall.classList.add('menu-item-disabled');
		}
	} else
		mnuInstall.classList.add('menu-item-disabled');
}

function clearLocalStorage() {
	localStorage.removeItem('hash-' + uuid);
	localStorage.removeItem('reg-' + uuid);
}

function clearDecryptDialog() {
  	decryptPasswordInput.value = '';
  	vernamKeyTextArea.value = '';
  	decryptShowPassword.checked = false;
  	decryptPasswordInput.type = 'password';
  	decryptShowVernamKey.checked = false;
  	vernamKeyTextArea.style.setProperty('-webkit-text-security', 'disc');
	decryptErrorMsg.style.visibility = 'hidden';
}

function clearRegisterDialog() {
	registerPasswordInput.value = '';
  	registerShowPassword.checked = false;
  	registerPasswordInput.type = 'password';
}

function clearBlockDialog() {
	blockErrorMsg.style.visibility = 'hidden';
}

function clearLoginDialog() {
	attributesDetailsHolder.innerHTML = '';
	userInput.value = '';
	loginPasswordInput.value = '';
	loginShowPassword.checked = false;
	loginPasswordInput.type = 'password';
	loginErrorMsg.style.visibility = 'hidden';
}

/*
 * Add cancel listener to dialogs Cancel/Close buttons
 */
function addDialogsCancelListeners(dialog, funcBeforeCancel) {
	const cancelButtons = document.querySelectorAll('.cancel-action');
	for(const cancelButton of cancelButtons) {
		cancelButton.addEventListener('click', (e)=> {
			if (funcBeforeCancel !== undefined)
				funcBeforeCancel();
    		dialog.close();
    	});
	}
}

/*
 * Add cancel listener to status messages close buttons
 */
function addStatusMessagesCancelListeners() {
	const cancelButtons = document.querySelectorAll('.close-message-icon');
	for(const cancelButton of cancelButtons) {
		cancelButton.addEventListener('click', (e)=> {
			const cancelButton = e.currentTarget;
			cancelButton.parentElement.style.display = 'none';
			statusMessageMargin.style.display = 'none';
    	});
	}
}

function signOut() {
	loggedIn = false;
	rootEl.innerHTML = '';
    if (hasUsers)
    	btnSignIn.style.display = 'flex';
    userComponent.style.display = 'none';
	userNameText.textContent = '';
	inactivityMessage.style.display = 'none';
	statusMessageMargin.style.display = 'none';
	displayResults(rootEl, mapPublic);
	remoteOptions = null;
    sessionTimeoutSec = 0;
    sessionTimeoutWarningSec = 0;
}

function readParams() {
	const localStorageHash = localStorage.getItem('hash-' + uuid);
	if (localStorageHash !== null)
		hash = localStorageHash;
	else {
		hash = window.location.hash;
		if (hash === null || hash === undefined)
			hash = '';
		if (hash.startsWith('#'))
			hash = hash.substring(1).trim();
	}
    let queryStr = '';
    const indQ = hash.indexOf('?');
    if (indQ < 0) {
       	queryStr = window.location.search;
       	if (queryStr === null || queryStr === undefined)
       		queryStr = '';
    } else {
    	queryStr = hash.substring(indQ);
    	hash = hash.substring(0, indQ);
    }
	if (hash != '')
		localStorage.setItem('hash-'+ uuid, hash);

    if (queryStr.startsWith('?'))
    	queryStr = queryStr.substring(1).trim();
    	
	if (queryStr == '')
		query = [];
	else
		query = queryStr.split(',');

 	let urlInHistory = location.href.split("#")[0].split("?")[0];
 	if (queryStr != '')
 		urlInHistory += '?' + queryStr;
	history.replaceState(null, '', urlInHistory);
}

function readLocalStorage() {
	hash = localStorage.getItem('hash-' + uuid);
	if (hash === null)
		hash = '';
	const wmkKey = 'wmk-' + uuid;
	wmk = localStorage.getItem(wmkKey);
	if (wmk === null) {
		wmk = uuidv4();
		localStorage.setItem(wmkKey, wmk);
	}
	regCode = localStorage.getItem('reg-' + uuid);
	if (regCode === null)
		regCode = '';
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//Section: Handle inactivety message
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

function logout() {
	if (loggedIn)
		signOut();
}

function writeInactivityMessage() {
	if (sessionTimeoutSec == 0 && sessionTimeoutWarningSec == 0)
		return;
	if (secondsTimeRemaining == 0)
		logout();
	else if (secondsTimeRemaining > 0) {
		inactivityMessage.style.display = 'block';
		inactivityMessage.innerHTML = `Your&nbsp;session&nbsp;is&nbsp;about&nbsp;to&nbsp;expire&nbsp;due&nbsp;to&nbsp;inactivity. Time&nbsp;remaining:&nbsp;<b>${secondsTimeRemaining}</b>&nbsp;seconds.`;
		statusMessageMargin.style.display = 'block';
		secondsTimeRemaining--;
	}
}

function resetWarningTimer() {
	if (sessionTimeoutSec == 0 && sessionTimeoutWarningSec == 0)
		return;
	inactivityMessage.style.display = 'none';
	statusMessageMargin.style.display = 'none';
	clearTimeout(timerWarning);
	clearTimeout(timerSecond);
	secondsTimeRemaining = sessionTimeoutWarningSec;

	const tw = 1000 * (sessionTimeoutSec > sessionTimeoutWarningSec ? sessionTimeoutSec - sessionTimeoutWarningSec : sessionTimeoutWarningSec);
	timerWarning = setTimeout(resetSecondTimer, tw);
}

function resetSecondTimer() {
	if (sessionTimeoutSec == 0 && sessionTimeoutWarningSec == 0)
		return;
	timerSecond = setInterval(writeInactivityMessage, 1000);
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Section: Bootstrap (PWA, favicon)
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const PRODUCT_VERSION = '1.01.01';
const FILE_NAME = "griffin.html";
const INDEX_URL = '/griffin/' + FILE_NAME;
const PRODUCT_NAME = "Griffin";
const ICON_144X144_DATA_URL = 'data:image/svg+xml;base64,' + btoa(new XMLSerializer().serializeToString(logoIcon));
const START_URL = 'https://xnbox.github.io' + INDEX_URL;


const ZERO_UUID = '00000000-0000-0000-0000-000000000000';
const ZERO_SHA_256 = '0000000000000000000000000000000000000000000000000000000000000000';
const ZERO_SUBJECT = 'Empty container';

//https://gist.github.com/serin113/3186244
/*
 * Lets you use your browser's back/forward buttons for in-page navigation by
 * adding custom 'next' and 'previous' events to the window object.
 *
 * Copyright (c) 2011 Tobias Schneider <schneider@jancona.com>
 * This script is freely distributable under the terms of the MIT license.
 *
 * Example:
 *
 *	window.addEventListener('next', function(){
 *		console.log('forward button clicked');
 *	}, false);
 *
 *	window.addEventListener('previous', function(){
 *		console.log('back button clicked');
 *	}, false);
 */

if(window.history && history.pushState){ // check for history api support
	window.addEventListener('load', function(){
		// create history states
		history.pushState(-1, null); // back state
		history.pushState(0, null); // main state
		history.pushState(1, null); // forward state
		history.go(-1); // start in main state
				
		this.addEventListener('popstate', function(event, state){
			// check history state and fire custom events
			if(state = event.state){
	
				event = document.createEvent('Event');
				event.initEvent(state > 0 ? 'next' : 'previous', true, true);
				this.dispatchEvent(event);
				
				// reset state
				history.go(-state);
			}
		}, false);
	}, false);
}

window.addEventListener('previous', function(){
	console.log('back button clicked');

	aboutDialog.close();

	decryptDialog.close();
	clearDecryptDialog();

	loginDialog.close();
	clearLoginDialog();

    registerDialog.close();
    clearRegisterDialog();

	unregisterDialog.close();

	blockDialog.close();
	clearBlockDialog();
}, false);
 
const headEl = document.querySelector('head');
const metaSha256El = headEl.querySelector('meta[name="sha256"]');
const metaSignatureEl = headEl.querySelector('meta[name="signature"]');
const metaContainerUuidEl = headEl.querySelector('meta[name="uuid"]');
const metaEncryptedDataSizeEl = headEl.querySelector('meta[name="size"]');

var showModal = function() {
    // some code here to show the HTML elements...

    window.history.pushState('backPressed', null, null);
    window.history.pushState('dummy', null, null);
    window.addEventListener('popstate', hideModal, { once: true });
};

var hideModal = function(event) {
    if (event.state == 'backPressed') {
        // hide the HTML elements
    }
};

/* Self integrity test */
// save
const savedDigest = metaSha256El.getAttribute('content');
metaSha256El.setAttribute('content', '');
digestMessage(getHTML()).then(digest => {
	console.log(digest);
	console.log(savedDigest);
	if (digest != savedDigest) {
		console.log('WARNING: Self integrity test failed');
		integrityTestErrorMessage.style.display = 'block';
	} else {
		console.log('INFO: Self integrity test passed');
		integrityTestOkMessage.style.display = 'block';
	}
	statusMessageMargin.style.display = 'block';

	//restore
	metaSha256El.setAttribute('content', savedDigest);
});

if (location.origin.startsWith('https') || location.origin.startsWith('http'))
	if('serviceWorker' in navigator)
		navigator.serviceWorker.register('griffin-sw.js');

setManifest(START_URL, PRODUCT_NAME, PRODUCT_NAME, ICON_144X144_DATA_URL);

let beforeinstallpromptEvent;
window.addEventListener('beforeinstallprompt', (e) => {
	beforeinstallpromptEvent = e;
	mnuInstall.classList.remove('menu-item-disabled');
	e.userChoice.then(function(choiceResult) {
		if (choiceResult.outcome === 'accepted') {
			beforeinstallpromptEvent = undefined;
			mnuInstall.classList.add('menu-item-disabled');
		}
	});
});

function setManifest(start_url, name, description, icon_data_url) {
	const ind1 = icon_data_url.indexOf(':');
	const ind2 = icon_data_url.indexOf(';');
	const type = icon_data_url.substring(ind1 + 1, ind2)

	let manifest = {
			"name" : encodeURIComponent(name),
			"short_name" : encodeURIComponent(name),
			"start_url" : encodeURI(start_url),
			"description" : encodeURIComponent(description),
			"display" : "standalone",
			"theme_color" : "DeepSkyBlue",
			"background_color" : "White",
			"icons" : [{
				"src" : encodeURI(icon_data_url),
				"sizes" : "144x144",
				"type" : type
			}],
			"file_handlers": [{
			           "action": "/griffin,html",
			           "name": name,
			           "accept": {
			               "text/xml": [".xml"]
			           },
			           "icons": [{
			   				"src" : encodeURI(icon_data_url),
							"sizes" : "144x144",
							"type" : type
						}]
			}]
		};
	let manifestStr = JSON.stringify(manifest);
	let hrefManifest = 'data:application/manifest+json,' + manifestStr;

	let linkManifestEl = headEl.querySelector('link[rel="manifest"]');
	if (linkManifestEl != null)
		headEl.removeChild(linkManifestEl);
	linkManifestEl = document.createElement('link');
	linkManifestEl.setAttribute('rel', 'manifest');
	linkManifestEl.setAttribute('href', hrefManifest);
	headEl.appendChild(linkManifestEl);
}

//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
// Section: Main
//----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

const windowEvents = ['load', 'resize', 'focus'];
windowEvents.forEach(function(name) {
	window.addEventListener(name, resetWarningTimer, true);
});
//
const documentEvents = ['mousedown', 'mousemove', 'keypress', 'keydown', 'touchstart', 'scroll'];
documentEvents.forEach(function(name) {
	document.addEventListener(name, resetWarningTimer, true);
});

document.addEventListener("click", (e) => {
	console.log(e.target);
	if (e.target != menuLeft && e.target != menuRight) {
			 if (e.target == menuIcon) {
				menuRight.style.display = 'none';
				if (menuLeft.style.display == 'flex')
 				menuLeft.style.display = 'none';
				else
					menuLeft.style.display = 'flex';
			 } else if (isAncestorOf(e.target, userComponent)) {
				menuLeft.style.display = 'none';
				if (menuRight.style.display == 'flex')
				menuRight.style.display = 'none';
				else
					menuRight.style.display = 'flex';
			 } else if (!e.target.classList.contains('menu-item')) {
				menuLeft.style.display = 'none';
				menuRight.style.display = 'none';
			 }
		}
});

document.addEventListener('keydown', e => {
	  if (e.key === 'Escape') {
		  menuLeft.style.display = 'none';
		  menuRight.style.display = 'none';
	  }
});

const MIN_ENCRYPTED_JSON = {
	config: {
		title: PRODUCT_NAME,
		favicon: ICON_144X144_DATA_URL,
		subject: ZERO_SUBJECT,
		validityNotBefore: '',
		validityNotAfter: '',
		stunUrls :[],
		remoteOptions: {}
	},
	usr: [],
	dlt: [],
	rmt: [],
	ips: [],
	ses: [],
	res :{}
};
const MIN_ENCRYPTED_JSON_STR = JSON.stringify(MIN_ENCRYPTED_JSON);
if (jsonHolder.textContent.trim() == '')
	jsonHolder.textContent = MIN_ENCRYPTED_JSON_STR;

let timerInactivety;
let timerWarning;
let timerSecond;

let secondsTimeRemaining;

let hasUsers;

let ip;
let xml = '';
//
let hash = '';
let wmk;
let regCode = '';
//
let size;
let sha256;
let subject;
let validityNotBefore;
let validityNotAfter;
//
let xmlFile;

let query = [];
let remoteOptions = null;
let loggedIn = false;
let sessionTimeoutSec = 0;
let sessionTimeoutWarningSec = 0;

let resEntryJsonsPublic;
let mapPublic;

const ID_LENGTH = 12;
const KEY_LENGTH = 18;
const STANDARD_KEY = new Uint8Array(KEY_LENGTH);
const uuid = metaContainerUuidEl.getAttribute('content');
const encryptedJsonStr = jsonHolder.textContent;
const encryptedJson = JSON.parse(encryptedJsonStr);
const config = encryptedJson['config'];

const WAS_EMPTY = uuid == ZERO_UUID;

const rootWrapperEl = document.getElementById('rootWrapper');
const rootEl = document.getElementById('root');
rootWrapperEl.appendChild(rootEl);
let lastComment;

readParams();
readLocalStorage();
addEventListener('hashchange', (event) => {
	readParams();
	readLocalStorage();
});

displayWallet();

</script></body></html>